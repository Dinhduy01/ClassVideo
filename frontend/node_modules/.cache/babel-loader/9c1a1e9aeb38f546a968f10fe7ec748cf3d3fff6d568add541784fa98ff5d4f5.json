{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source) if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)) {\n    if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n  }\n  return target;\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/constants.ts\nvar cssPrefix = \"lk\";\n\n// src/utils.ts\nimport { LocalParticipant, RemoteParticipant } from \"livekit-client\";\n\n// src/track-reference/track-reference.types.ts\nfunction isTrackReference(trackReference) {\n  if (typeof trackReference === \"undefined\") {\n    return false;\n  }\n  return isTrackReferenceSubscribed(trackReference) || isTrackReferencePublished(trackReference);\n}\nfunction isTrackReferenceSubscribed(trackReference) {\n  var _a;\n  if (!trackReference) {\n    return false;\n  }\n  return trackReference.hasOwnProperty(\"participant\") && trackReference.hasOwnProperty(\"source\") && trackReference.hasOwnProperty(\"track\") && typeof ((_a = trackReference.publication) == null ? void 0 : _a.track) !== \"undefined\";\n}\nfunction isTrackReferencePublished(trackReference) {\n  if (!trackReference) {\n    return false;\n  }\n  return trackReference.hasOwnProperty(\"participant\") && trackReference.hasOwnProperty(\"source\") && trackReference.hasOwnProperty(\"publication\") && typeof trackReference.publication !== \"undefined\";\n}\nfunction isTrackReferencePlaceholder(trackReference) {\n  if (!trackReference) {\n    return false;\n  }\n  return trackReference.hasOwnProperty(\"participant\") && trackReference.hasOwnProperty(\"source\") && typeof trackReference.publication === \"undefined\";\n}\n\n// src/track-reference/track-reference.utils.ts\nfunction getTrackReferenceId(trackReference) {\n  if (typeof trackReference === \"string\" || typeof trackReference === \"number\") {\n    return `${trackReference}`;\n  } else if (isTrackReferencePlaceholder(trackReference)) {\n    return `${trackReference.participant.identity}_${trackReference.source}_placeholder`;\n  } else if (isTrackReference(trackReference)) {\n    return `${trackReference.participant.identity}_${trackReference.publication.source}_${trackReference.publication.trackSid}`;\n  } else {\n    throw new Error(`Can't generate a id for the given track reference: ${trackReference}`);\n  }\n}\nfunction getTrackReferenceSource(trackReference) {\n  if (isTrackReference(trackReference)) {\n    return trackReference.publication.source;\n  } else {\n    return trackReference.source;\n  }\n}\nfunction isEqualTrackRef(a, b) {\n  if (a === void 0 || b === void 0) {\n    return false;\n  }\n  if (isTrackReference(a) && isTrackReference(b)) {\n    return a.publication.trackSid === b.publication.trackSid;\n  } else {\n    return getTrackReferenceId(a) === getTrackReferenceId(b);\n  }\n}\nfunction isTrackReferencePinned(trackReference, pinState) {\n  if (typeof pinState === \"undefined\") {\n    return false;\n  }\n  if (isTrackReference(trackReference)) {\n    return pinState.some(pinnedTrackReference => pinnedTrackReference.participant.identity === trackReference.participant.identity && isTrackReference(pinnedTrackReference) && pinnedTrackReference.publication.trackSid === trackReference.publication.trackSid);\n  } else if (isTrackReferencePlaceholder(trackReference)) {\n    return pinState.some(pinnedTrackReference => pinnedTrackReference.participant.identity === trackReference.participant.identity && isTrackReferencePlaceholder(pinnedTrackReference) && pinnedTrackReference.source === trackReference.source);\n  } else {\n    return false;\n  }\n}\nfunction isPlaceholderReplacement(currentTrackRef, nextTrackRef) {\n  return isTrackReferencePlaceholder(currentTrackRef) && isTrackReference(nextTrackRef) && nextTrackRef.participant.identity === currentTrackRef.participant.identity && nextTrackRef.source === currentTrackRef.source;\n}\n\n// src/utils.ts\nfunction isLocal(p) {\n  return p instanceof LocalParticipant;\n}\nfunction isRemote(p) {\n  return p instanceof RemoteParticipant;\n}\nvar attachIfSubscribed = (publication, element) => {\n  if (!publication) return;\n  const {\n    isSubscribed,\n    track\n  } = publication;\n  if (element && track) {\n    if (isSubscribed) {\n      track.attach(element);\n    } else {\n      track.detach(element);\n    }\n  }\n};\nfunction isParticipantSourcePinned(participant, source, pinState) {\n  if (pinState === void 0) {\n    return false;\n  }\n  return pinState.some(_ref => {\n    let {\n      source: pinnedSource,\n      participant: pinnedParticipant\n    } = _ref;\n    return pinnedSource === source && pinnedParticipant.identity === participant.identity;\n  });\n}\nfunction isParticipantTrackReferencePinned(trackRef, pinState) {\n  if (pinState === void 0) {\n    return false;\n  }\n  return pinState.some(pinnedTrackRef => isEqualTrackRef(pinnedTrackRef, trackRef));\n}\nfunction getScrollBarWidth() {\n  const inner = document.createElement(\"p\");\n  inner.style.width = \"100%\";\n  inner.style.height = \"200px\";\n  const outer = document.createElement(\"div\");\n  outer.style.position = \"absolute\";\n  outer.style.top = \"0px\";\n  outer.style.left = \"0px\";\n  outer.style.visibility = \"hidden\";\n  outer.style.width = \"200px\";\n  outer.style.height = \"150px\";\n  outer.style.overflow = \"hidden\";\n  outer.appendChild(inner);\n  document.body.appendChild(outer);\n  const w1 = inner.offsetWidth;\n  outer.style.overflow = \"scroll\";\n  let w2 = inner.offsetWidth;\n  if (w1 === w2) {\n    w2 = outer.clientWidth;\n  }\n  document.body.removeChild(outer);\n  const scrollBarWidth = w1 - w2;\n  return scrollBarWidth;\n}\n\n// src/helper/detectMobileBrowser.ts\nfunction isWeb() {\n  return typeof document !== \"undefined\";\n}\nfunction isMobileBrowser() {\n  return isWeb() ? /Mobi/i.test(window.navigator.userAgent) : false;\n}\n\n// src/helper/url-regex.ts\nfunction createUrlRegExp(options) {\n  options = __spreadValues({}, options);\n  const protocol = `(?:(?:[a-z]+:)?//)?`;\n  const auth = \"(?:\\\\S+(?::\\\\S*)?@)?\";\n  const ip = new RegExp(\"(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}\", \"g\").source;\n  const host = \"(?:(?:[a-z\\\\u00a1-\\\\uffff0-9][-_]*)*[a-z\\\\u00a1-\\\\uffff0-9]+)\";\n  const domain = \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*\";\n  const tld = `(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))\\\\.?`;\n  const port = \"(?::\\\\d{2,5})?\";\n  const path = '(?:[/?#][^\\\\s\"]*)?';\n  const regex = `(?:${protocol}|www\\\\.)${auth}(?:localhost|${ip}|${host}${domain}${tld})${port}${path}`;\n  return options.exact ? new RegExp(`(?:^${regex}$)`, \"i\") : new RegExp(regex, \"ig\");\n}\n\n// src/helper/emailRegex.ts\nimport createEmailRegExp from \"email-regex\";\n\n// src/helper/floating-menu.ts\nimport { computePosition, flip, offset, shift } from \"@floating-ui/dom\";\nfunction computeMenuPosition(button, menu) {\n  return __async(this, null, function* () {\n    const {\n      x,\n      y\n    } = yield computePosition(button, menu, {\n      placement: \"top\",\n      middleware: [offset(6), flip(), shift({\n        padding: 5\n      })]\n    });\n    return {\n      x,\n      y\n    };\n  });\n}\nfunction wasClickOutside(insideElement, event) {\n  const isOutside = !insideElement.contains(event.target);\n  return isOutside;\n}\n\n// src/helper/tokenizer.ts\nvar createDefaultGrammar = () => {\n  return {\n    email: createEmailRegExp(),\n    url: createUrlRegExp({})\n  };\n};\nfunction tokenize(input, grammar) {\n  const matches = Object.entries(grammar).map((_ref2, weight) => {\n    let [type, rx] = _ref2;\n    return Array.from(input.matchAll(rx)).map(_ref3 => {\n      let {\n        index,\n        0: content\n      } = _ref3;\n      return {\n        type,\n        weight,\n        content,\n        index: index != null ? index : 0\n      };\n    });\n  }).flat().sort((a, b) => {\n    const d = a.index - b.index;\n    return d !== 0 ? d : a.weight - b.weight;\n  }).filter((_ref4, i, arr) => {\n    let {\n      index\n    } = _ref4;\n    if (i === 0) return true;\n    const prev = arr[i - 1];\n    return prev.index + prev.content.length <= index;\n  });\n  const tokens = [];\n  let pos = 0;\n  for (const {\n    type,\n    content,\n    index\n  } of matches) {\n    if (index > pos) tokens.push(input.substring(pos, index));\n    tokens.push({\n      type,\n      content\n    });\n    pos = index + content.length;\n  }\n  if (input.length > pos) tokens.push(input.substring(pos));\n  return tokens;\n}\n\n// src/helper/eventGroups.ts\nimport { ParticipantEvent, RoomEvent } from \"livekit-client\";\nvar allRemoteParticipantRoomEvents = [RoomEvent.ConnectionStateChanged, RoomEvent.RoomMetadataChanged, RoomEvent.ActiveSpeakersChanged, RoomEvent.ConnectionQualityChanged, RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ParticipantPermissionsChanged, RoomEvent.ParticipantMetadataChanged, RoomEvent.TrackMuted, RoomEvent.TrackUnmuted, RoomEvent.TrackPublished, RoomEvent.TrackUnpublished, RoomEvent.TrackStreamStateChanged, RoomEvent.TrackSubscriptionFailed, RoomEvent.TrackSubscriptionPermissionChanged, RoomEvent.TrackSubscriptionStatusChanged];\nvar allParticipantRoomEvents = [...allRemoteParticipantRoomEvents, RoomEvent.LocalTrackPublished, RoomEvent.LocalTrackUnpublished];\nvar allRemoteParticipantEvents = [ParticipantEvent.ConnectionQualityChanged, ParticipantEvent.IsSpeakingChanged, ParticipantEvent.ParticipantMetadataChanged, ParticipantEvent.ParticipantPermissionsChanged, ParticipantEvent.TrackMuted, ParticipantEvent.TrackUnmuted, ParticipantEvent.TrackPublished, ParticipantEvent.TrackUnpublished, ParticipantEvent.TrackStreamStateChanged, ParticipantEvent.TrackSubscriptionFailed, ParticipantEvent.TrackSubscriptionPermissionChanged, ParticipantEvent.TrackSubscriptionStatusChanged];\nvar allParticipantEvents = [...allRemoteParticipantEvents, ParticipantEvent.LocalTrackPublished, ParticipantEvent.LocalTrackUnpublished];\n\n// src/logger.ts\nimport { setLogLevel as setClientSdkLogLevel, setLogExtension as setClientSdkLogExtension, LogLevel as LogLevelEnum } from \"livekit-client\";\nimport loglevel from \"loglevel\";\nvar log = loglevel.getLogger(\"lk-components-js\");\nlog.setDefaultLevel(\"WARN\");\nfunction setLogLevel(level) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _a;\n  log.setLevel(level);\n  setClientSdkLogLevel((_a = options.liveKitClientLogLevel) != null ? _a : level);\n}\nfunction setLogExtension(extension) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _a;\n  const originalFactory = log.methodFactory;\n  log.methodFactory = (methodName, configLevel, loggerName) => {\n    const rawMethod = originalFactory(methodName, configLevel, loggerName);\n    const logLevel = LogLevelEnum[methodName];\n    const needLog = logLevel >= configLevel && logLevel < LogLevelEnum.silent;\n    return (msg, context) => {\n      if (context) rawMethod(msg, context);else rawMethod(msg);\n      if (needLog) {\n        extension(logLevel, msg, context);\n      }\n    };\n  };\n  log.setLevel(log.getLevel());\n  setClientSdkLogExtension((_a = options.liveKitClientLogExtension) != null ? _a : extension);\n}\n\n// src/helper/grid-layouts.ts\nvar GRID_LAYOUTS = [{\n  columns: 1,\n  rows: 1,\n  name: \"1x1\",\n  minTiles: 1,\n  maxTiles: 1,\n  minWidth: 0,\n  minHeight: 0\n}, {\n  columns: 1,\n  rows: 2,\n  name: \"1x2\",\n  minTiles: 2,\n  maxTiles: 2,\n  minWidth: 0,\n  minHeight: 0\n}, {\n  columns: 2,\n  rows: 1,\n  name: \"2x1\",\n  minTiles: 2,\n  maxTiles: 2,\n  minWidth: 900,\n  minHeight: 0\n}, {\n  columns: 2,\n  rows: 2,\n  name: \"2x2\",\n  minTiles: 3,\n  maxTiles: 4,\n  minWidth: 560,\n  minHeight: 0\n}, {\n  columns: 3,\n  rows: 3,\n  name: \"3x3\",\n  minTiles: 5,\n  maxTiles: 9,\n  minWidth: 700,\n  minHeight: 0\n}, {\n  columns: 4,\n  rows: 4,\n  name: \"4x4\",\n  minTiles: 10,\n  maxTiles: 16,\n  minWidth: 960,\n  minHeight: 0\n}, {\n  columns: 5,\n  rows: 5,\n  name: \"5x5\",\n  minTiles: 17,\n  maxTiles: 25,\n  minWidth: 1100,\n  minHeight: 0\n}];\nfunction selectGridLayout(layouts, participantCount, width, height) {\n  let currentLayoutIndex = 0;\n  let layout = layouts.find((layout_, index, allLayouts) => {\n    currentLayoutIndex = index;\n    const isBiggerLayoutAvailable = allLayouts.findIndex((l, i) => {\n      const layoutIsBiggerThanCurrent = i > index;\n      const layoutFitsSameAmountOfParticipants = l.maxTiles === layout_.maxTiles;\n      return layoutIsBiggerThanCurrent && layoutFitsSameAmountOfParticipants;\n    }) !== -1;\n    return layout_.maxTiles >= participantCount && !isBiggerLayoutAvailable;\n  });\n  if (layout === void 0) {\n    layout = layouts[layouts.length - 1];\n    if (layout) {\n      log.warn(`No layout found for: participantCount: ${participantCount}, width/height: ${width}/${height} fallback to biggest available layout (${layout.name}).`);\n    } else {\n      throw new Error(`No layout or fallback layout found.`);\n    }\n  }\n  if (width < layout.minWidth || height < layout.minHeight) {\n    if (currentLayoutIndex > 0) {\n      const smallerLayout = layouts[currentLayoutIndex - 1];\n      layout = selectGridLayout(layouts.slice(0, currentLayoutIndex), smallerLayout.maxTiles, width, height);\n    }\n  }\n  return layout;\n}\n\n// src/helper/set-helper.ts\nfunction setDifference(setA, setB) {\n  const _difference = new Set(setA);\n  for (const elem of setB) {\n    _difference.delete(elem);\n  }\n  return _difference;\n}\n\n// src/helper/featureDetection.ts\nfunction supportsScreenSharing() {\n  return typeof navigator !== \"undefined\" && navigator.mediaDevices && !!navigator.mediaDevices.getDisplayMedia;\n}\n\n// src/types.ts\nvar PIN_DEFAULT_STATE = [];\nvar WIDGET_DEFAULT_STATE = {\n  showChat: false,\n  unreadMessages: 0\n};\nfunction isSourceWitOptions(source) {\n  return typeof source === \"object\";\n}\nfunction isSourcesWithOptions(sources) {\n  return Array.isArray(sources) && sources.filter(isSourceWitOptions).length > 0;\n}\n\n// src/sorting/sort-track-bundles.ts\nimport { Track as Track2 } from \"livekit-client\";\n\n// src/sorting/base-sort-functions.ts\nimport { Track } from \"livekit-client\";\nfunction sortParticipantsByAudioLevel(a, b) {\n  return b.audioLevel - a.audioLevel;\n}\nfunction sortParticipantsByIsSpeaking(a, b) {\n  if (a.isSpeaking === b.isSpeaking) {\n    return 0;\n  } else {\n    return a.isSpeaking ? -1 : 1;\n  }\n}\nfunction sortParticipantsByLastSpokenAT(a, b) {\n  var _a, _b, _c, _d;\n  if (a.lastSpokeAt !== void 0 || b.lastSpokeAt !== void 0) {\n    return ((_b = (_a = b.lastSpokeAt) == null ? void 0 : _a.getTime()) != null ? _b : 0) - ((_d = (_c = a.lastSpokeAt) == null ? void 0 : _c.getTime()) != null ? _d : 0);\n  } else {\n    return 0;\n  }\n}\nfunction sortParticipantsByJoinedAt(a, b) {\n  var _a, _b, _c, _d;\n  return ((_b = (_a = a.joinedAt) == null ? void 0 : _a.getTime()) != null ? _b : 0) - ((_d = (_c = b.joinedAt) == null ? void 0 : _c.getTime()) != null ? _d : 0);\n}\nfunction sortTrackReferencesByType(a, b) {\n  if (isTrackReference(a)) {\n    if (isTrackReference(b)) {\n      return 0;\n    } else {\n      return -1;\n    }\n  } else if (isTrackReference(b)) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\nfunction sortTrackRefsByIsCameraEnabled(a, b) {\n  const aVideo = a.participant.isCameraEnabled;\n  const bVideo = b.participant.isCameraEnabled;\n  if (aVideo !== bVideo) {\n    if (aVideo) {\n      return -1;\n    } else {\n      return 1;\n    }\n  } else {\n    return 0;\n  }\n}\n\n// src/sorting/sort-track-bundles.ts\nfunction sortTrackReferences(tracks) {\n  const localTracks = [];\n  const screenShareTracks = [];\n  const cameraTracks = [];\n  const undefinedTracks = [];\n  tracks.forEach(trackRef => {\n    if (trackRef.participant.isLocal && trackRef.source === Track2.Source.Camera) {\n      localTracks.push(trackRef);\n    } else if (trackRef.source === Track2.Source.ScreenShare) {\n      screenShareTracks.push(trackRef);\n    } else if (trackRef.source === Track2.Source.Camera) {\n      cameraTracks.push(trackRef);\n    } else {\n      undefinedTracks.push(trackRef);\n    }\n  });\n  const sortedScreenShareTracks = sortScreenShareTracks(screenShareTracks);\n  const sortedCameraTracks = sortCameraTracks(cameraTracks);\n  return [...localTracks, ...sortedScreenShareTracks, ...sortedCameraTracks, ...undefinedTracks];\n}\nfunction sortScreenShareTracks(screenShareTracks) {\n  const localScreenShares = [];\n  const remoteScreenShares = [];\n  screenShareTracks.forEach(trackRef => {\n    if (trackRef.participant.isLocal) {\n      localScreenShares.push(trackRef);\n    } else {\n      remoteScreenShares.push(trackRef);\n    }\n  });\n  localScreenShares.sort((a, b) => sortParticipantsByJoinedAt(a.participant, b.participant));\n  remoteScreenShares.sort((a, b) => sortParticipantsByJoinedAt(a.participant, b.participant));\n  const sortedScreenShareTrackRefs = [...remoteScreenShares, ...localScreenShares];\n  return sortedScreenShareTrackRefs;\n}\nfunction sortCameraTracks(cameraTrackReferences) {\n  const localCameraTracks = [];\n  const remoteCameraTracks = [];\n  cameraTrackReferences.forEach(trackRef => {\n    if (trackRef.participant.isLocal) {\n      localCameraTracks.push(trackRef);\n    } else {\n      remoteCameraTracks.push(trackRef);\n    }\n  });\n  remoteCameraTracks.sort((a, b) => {\n    if (a.participant.isSpeaking && b.participant.isSpeaking) {\n      return sortParticipantsByAudioLevel(a.participant, b.participant);\n    }\n    if (a.participant.isSpeaking !== b.participant.isSpeaking) {\n      return sortParticipantsByIsSpeaking(a.participant, b.participant);\n    }\n    if (a.participant.lastSpokeAt !== b.participant.lastSpokeAt) {\n      return sortParticipantsByLastSpokenAT(a.participant, b.participant);\n    }\n    if (isTrackReference(a) !== isTrackReference(b)) {\n      return sortTrackReferencesByType(a, b);\n    }\n    if (a.participant.isCameraEnabled !== b.participant.isCameraEnabled) {\n      return sortTrackRefsByIsCameraEnabled(a, b);\n    }\n    return sortParticipantsByJoinedAt(a.participant, b.participant);\n  });\n  return [...localCameraTracks, ...remoteCameraTracks];\n}\n\n// src/sorting/sort-participants.ts\nimport { LocalParticipant as LocalParticipant2 } from \"livekit-client\";\nfunction sortParticipants(participants) {\n  const sortedParticipants = [...participants];\n  sortedParticipants.sort((a, b) => {\n    if (a.isSpeaking && b.isSpeaking) {\n      return sortParticipantsByAudioLevel(a, b);\n    }\n    if (a.isSpeaking !== b.isSpeaking) {\n      return sortParticipantsByIsSpeaking(a, b);\n    }\n    if (a.lastSpokeAt !== b.lastSpokeAt) {\n      return sortParticipantsByLastSpokenAT(a, b);\n    }\n    const aVideo = a.videoTracks.size > 0;\n    const bVideo = b.videoTracks.size > 0;\n    if (aVideo !== bVideo) {\n      if (aVideo) {\n        return -1;\n      } else {\n        return 1;\n      }\n    }\n    return sortParticipantsByJoinedAt(a, b);\n  });\n  const localParticipant = sortedParticipants.find(p => p instanceof LocalParticipant2);\n  if (localParticipant) {\n    const localIdx = sortedParticipants.indexOf(localParticipant);\n    if (localIdx >= 0) {\n      sortedParticipants.splice(localIdx, 1);\n      if (sortedParticipants.length > 0) {\n        sortedParticipants.splice(0, 0, localParticipant);\n      } else {\n        sortedParticipants.push(localParticipant);\n      }\n    }\n  }\n  return sortedParticipants;\n}\n\n// src/helper/array-helper.ts\nfunction chunk(input, size) {\n  return input.reduce((arr, item, idx) => {\n    return idx % size === 0 ? [...arr, [item]] : [...arr.slice(0, -1), [...arr.slice(-1)[0], item]];\n  }, []);\n}\nfunction zip(a1, a2) {\n  const resultLength = Math.max(a1.length, a2.length);\n  return new Array(resultLength).fill([]).map((_val, idx) => [a1[idx], a2[idx]]);\n}\nfunction differenceBy(a1, a2, by) {\n  return a1.filter(c => !a2.map(v => by(v)).includes(by(c)));\n}\n\n// src/track-reference/test-utils.ts\nimport { Participant, Track as Track3, TrackPublication } from \"livekit-client\";\nfunction flatTrackReferenceArray(list) {\n  return list.map(item => {\n    if (typeof item === \"string\" || typeof item === \"number\") {\n      return `${item}`;\n    } else {\n      return getTrackReferenceId(item);\n    }\n  });\n}\n\n// src/sorting/tile-array-update.ts\nfunction visualPageChange(state, next) {\n  return {\n    dropped: differenceBy(state, next, getTrackReferenceId),\n    added: differenceBy(next, state, getTrackReferenceId)\n  };\n}\nfunction listNeedsUpdating(changes) {\n  return changes.added.length !== 0 || changes.dropped.length !== 0;\n}\nfunction findIndex(trackReference, trackReferences) {\n  const indexToReplace = trackReferences.findIndex(trackReference_ => getTrackReferenceId(trackReference_) === getTrackReferenceId(trackReference));\n  if (indexToReplace === -1) {\n    throw new Error(`Element not part of the array: ${getTrackReferenceId(trackReference)} not in ${flatTrackReferenceArray(trackReferences)}`);\n  }\n  return indexToReplace;\n}\nfunction swapItems(moveForward, moveBack, trackReferences) {\n  const indexToReplace = findIndex(moveForward, trackReferences);\n  const indexReplaceWith = findIndex(moveBack, trackReferences);\n  trackReferences.splice(indexToReplace, 1, moveBack);\n  trackReferences.splice(indexReplaceWith, 1, moveForward);\n  return trackReferences;\n}\nfunction dropItem(itemToDrop, list) {\n  const indexOfElementToDrop = findIndex(itemToDrop, list);\n  list.splice(indexOfElementToDrop, 1);\n  return list;\n}\nfunction addItem(itemToAdd, list) {\n  return [...list, itemToAdd];\n}\nfunction divideIntoPages(list, maxElementsOnPage) {\n  const pages = chunk(list, maxElementsOnPage);\n  return pages;\n}\nfunction updatePages(currentList, nextList, maxItemsOnPage) {\n  let updatedList = refreshList(currentList, nextList);\n  if (updatedList.length < nextList.length) {\n    const addedItems = differenceBy(nextList, updatedList, getTrackReferenceId);\n    updatedList = [...updatedList, ...addedItems];\n  }\n  const currentPages = divideIntoPages(updatedList, maxItemsOnPage);\n  const nextPages = divideIntoPages(nextList, maxItemsOnPage);\n  zip(currentPages, nextPages).forEach((_ref5, pageIndex) => {\n    let [currentPage, nextPage] = _ref5;\n    if (currentPage && nextPage) {\n      const updatedPage = divideIntoPages(updatedList, maxItemsOnPage)[pageIndex];\n      const changes = visualPageChange(updatedPage, nextPage);\n      if (listNeedsUpdating(changes)) {\n        log.debug(`Detected visual changes on page: ${pageIndex}, current: ${flatTrackReferenceArray(currentPage)}, next: ${flatTrackReferenceArray(nextPage)}`, {\n          changes\n        });\n        if (changes.added.length === changes.dropped.length) {\n          zip(changes.added, changes.dropped).forEach(_ref6 => {\n            let [added, dropped] = _ref6;\n            if (added && dropped) {\n              updatedList = swapItems(added, dropped, updatedList);\n            } else {\n              throw new Error(`For a swap action we need a addition and a removal one is missing: ${added}, ${dropped}`);\n            }\n          });\n        }\n        if (changes.added.length === 0 && changes.dropped.length > 0) {\n          changes.dropped.forEach(item => {\n            updatedList = dropItem(item, updatedList);\n          });\n        }\n        if (changes.added.length > 0 && changes.dropped.length === 0) {\n          changes.added.forEach(item => {\n            updatedList = addItem(item, updatedList);\n          });\n        }\n      }\n    }\n  });\n  if (updatedList.length > nextList.length) {\n    const missingItems = differenceBy(updatedList, nextList, getTrackReferenceId);\n    updatedList = updatedList.filter(item => !missingItems.map(getTrackReferenceId).includes(getTrackReferenceId(item)));\n  }\n  return updatedList;\n}\nfunction refreshList(currentList, nextList) {\n  return currentList.map(currentItem => {\n    const updateForCurrentItem = nextList.find(newItem_ =>\n    // If the IDs match or ..\n    getTrackReferenceId(currentItem) === getTrackReferenceId(newItem_) ||\n    // ... if the current item is a placeholder and the new item is the track reference can replace it.\n    typeof currentItem !== \"number\" && isTrackReferencePlaceholder(currentItem) && isTrackReference(newItem_) && isPlaceholderReplacement(currentItem, newItem_));\n    return updateForCurrentItem != null ? updateForCurrentItem : currentItem;\n  });\n}\n\n// src/components/mediaToggle.ts\nimport { Track as Track7 } from \"livekit-client\";\nimport { Subject as Subject2, map as map4, startWith as startWith4 } from \"rxjs\";\n\n// src/observables/participant.ts\nimport { ParticipantEvent as ParticipantEvent2, RoomEvent as RoomEvent3, Track as Track6 } from \"livekit-client\";\nimport { map as map3, switchMap, Observable as Observable2, startWith as startWith3 } from \"rxjs\";\n\n// src/observables/room.ts\nimport { Subject, map, Observable, startWith, finalize, filter, concat } from \"rxjs\";\nimport { LocalParticipant as LocalParticipant3, Room, RoomEvent as RoomEvent2, Track as Track4 } from \"livekit-client\";\nfunction observeRoomEvents(room) {\n  for (var _len = arguments.length, events = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    events[_key - 1] = arguments[_key];\n  }\n  const observable = new Observable(subscribe => {\n    const onRoomUpdate = () => {\n      subscribe.next(room);\n    };\n    events.forEach(evt => {\n      room.on(evt, onRoomUpdate);\n    });\n    const unsubscribe = () => {\n      events.forEach(evt => {\n        room.off(evt, onRoomUpdate);\n      });\n    };\n    return unsubscribe;\n  }).pipe(startWith(room));\n  return observable;\n}\nfunction roomEventSelector(room, event) {\n  const observable = new Observable(subscribe => {\n    const update = function () {\n      for (var _len2 = arguments.length, params = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        params[_key2] = arguments[_key2];\n      }\n      subscribe.next(params);\n    };\n    room.on(event, update);\n    const unsubscribe = () => {\n      room.off(event, update);\n    };\n    return unsubscribe;\n  });\n  return observable;\n}\nfunction roomObserver(room) {\n  const observable = observeRoomEvents(room, RoomEvent2.ParticipantConnected, RoomEvent2.ParticipantDisconnected, RoomEvent2.ActiveSpeakersChanged, RoomEvent2.TrackSubscribed, RoomEvent2.TrackUnsubscribed, RoomEvent2.LocalTrackPublished, RoomEvent2.LocalTrackUnpublished, RoomEvent2.AudioPlaybackStatusChanged, RoomEvent2.ConnectionStateChanged).pipe(startWith(room));\n  return observable;\n}\nfunction connectionStateObserver(room) {\n  return roomEventSelector(room, RoomEvent2.ConnectionStateChanged).pipe(map(_ref7 => {\n    let [connectionState] = _ref7;\n    return connectionState;\n  }), startWith(room.state));\n}\nfunction screenShareObserver(room) {\n  let screenShareSubscriber;\n  const observers = [];\n  const observable = new Observable(subscriber => {\n    screenShareSubscriber = subscriber;\n    return () => {\n      observers.forEach(observer => {\n        observer.unsubscribe();\n      });\n    };\n  });\n  const screenShareTracks = [];\n  const handleSub = (publication, participant) => {\n    if (publication.source !== Track4.Source.ScreenShare && publication.source !== Track4.Source.ScreenShareAudio) {\n      return;\n    }\n    let trackMap = screenShareTracks.find(tr => tr.participant.identity === participant.identity);\n    const getScreenShareTracks = participant2 => {\n      return participant2.getTracks().filter(track => (track.source === Track4.Source.ScreenShare || track.source === Track4.Source.ScreenShareAudio) && track.track);\n    };\n    if (!trackMap) {\n      trackMap = {\n        participant,\n        tracks: getScreenShareTracks(participant)\n      };\n    } else {\n      const index = screenShareTracks.indexOf(trackMap);\n      screenShareTracks.splice(index, 1);\n      trackMap.tracks = getScreenShareTracks(participant);\n    }\n    if (trackMap.tracks.length > 0) {\n      screenShareTracks.push(trackMap);\n    }\n    screenShareSubscriber.next(screenShareTracks);\n  };\n  observers.push(roomEventSelector(room, RoomEvent2.TrackSubscribed).subscribe(_ref8 => {\n    let [, ...args] = _ref8;\n    return handleSub(...args);\n  }));\n  observers.push(roomEventSelector(room, RoomEvent2.TrackUnsubscribed).subscribe(_ref9 => {\n    let [, ...args] = _ref9;\n    return handleSub(...args);\n  }));\n  observers.push(roomEventSelector(room, RoomEvent2.LocalTrackPublished).subscribe(args => handleSub(...args)));\n  observers.push(roomEventSelector(room, RoomEvent2.LocalTrackUnpublished).subscribe(args => {\n    handleSub(...args);\n  }));\n  observers.push(roomEventSelector(room, RoomEvent2.TrackMuted).subscribe(args => {\n    handleSub(...args);\n  }));\n  observers.push(roomEventSelector(room, RoomEvent2.TrackUnmuted).subscribe(args => {\n    handleSub(...args);\n  }));\n  setTimeout(() => {\n    for (const p of room.participants.values()) {\n      p.getTracks().forEach(track => {\n        handleSub(track, p);\n      });\n    }\n  }, 1);\n  return observable;\n}\nfunction roomInfoObserver(room) {\n  const observer = observeRoomEvents(room, RoomEvent2.RoomMetadataChanged, RoomEvent2.ConnectionStateChanged).pipe(map(r => {\n    return {\n      name: r.name,\n      metadata: r.metadata\n    };\n  }));\n  return observer;\n}\nfunction activeSpeakerObserver(room) {\n  return roomEventSelector(room, RoomEvent2.ActiveSpeakersChanged).pipe(map(_ref10 => {\n    let [speakers] = _ref10;\n    return speakers;\n  }));\n}\nfunction createMediaDeviceObserver(kind, onError) {\n  let requestPermissions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var _a;\n  const onDeviceChange = () => __async(this, null, function* () {\n    try {\n      const newDevices = yield Room.getLocalDevices(kind, requestPermissions);\n      deviceSubject.next(newDevices);\n    } catch (e) {\n      onError == null ? void 0 : onError(e);\n    }\n  });\n  const deviceSubject = new Subject();\n  const observable = deviceSubject.pipe(finalize(() => {\n    var _a2;\n    (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.removeEventListener(\"devicechange\", onDeviceChange);\n  }));\n  if (typeof window !== \"undefined\") {\n    if (!window.isSecureContext) {\n      throw new Error(`Accessing media devices is available only in secure contexts (HTTPS and localhost), in some or all supporting browsers. See: https://developer.mozilla.org/en-US/docs/Web/API/Navigator/mediaDevices`);\n    }\n    (_a = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a.addEventListener(\"devicechange\", onDeviceChange);\n  }\n  return concat(Room.getLocalDevices(kind, requestPermissions).catch(e => onError == null ? void 0 : onError(e)), observable);\n}\nfunction createDataObserver(room) {\n  return roomEventSelector(room, RoomEvent2.DataReceived);\n}\nfunction roomAudioPlaybackAllowedObservable(room) {\n  const observable = observeRoomEvents(room, RoomEvent2.AudioPlaybackStatusChanged).pipe(map(room2 => {\n    return {\n      canPlayAudio: room2.canPlaybackAudio\n    };\n  }));\n  return observable;\n}\nfunction roomVideoPlaybackAllowedObservable(room) {\n  const observable = observeRoomEvents(room, RoomEvent2.VideoPlaybackStatusChanged).pipe(map(room2 => {\n    return {\n      canPlayVideo: room2.canPlaybackVideo\n    };\n  }));\n  return observable;\n}\nfunction createActiveDeviceObservable(room, kind) {\n  return roomEventSelector(room, RoomEvent2.ActiveDeviceChanged).pipe(filter(_ref11 => {\n    let [kindOfDevice] = _ref11;\n    return kindOfDevice === kind;\n  }), map(_ref12 => {\n    let [kind2, deviceId] = _ref12;\n    log.debug(\"activeDeviceObservable | RoomEvent.ActiveDeviceChanged\", {\n      kind: kind2,\n      deviceId\n    });\n    return deviceId;\n  }), startWith(room.getActiveDevice(kind)));\n}\nfunction encryptionStatusObservable(room, participant) {\n  return roomEventSelector(room, RoomEvent2.ParticipantEncryptionStatusChanged).pipe(filter(_ref13 => {\n    let [, p] = _ref13;\n    return participant.identity === (p == null ? void 0 : p.identity) || !p && participant.identity === room.localParticipant.identity;\n  }), map(_ref14 => {\n    let [encrypted] = _ref14;\n    return encrypted;\n  }), startWith(participant instanceof LocalParticipant3 ? participant.isE2EEEnabled : participant.isEncrypted));\n}\n\n// src/components/mediaTrack.ts\nimport { Track as Track5 } from \"livekit-client\";\nimport { map as map2, startWith as startWith2 } from \"rxjs\";\n\n// src/styles-interface/class-prefixer.ts\nfunction prefixClass(unprefixedClassName) {\n  return `${cssPrefix}-${unprefixedClassName}`;\n}\n\n// src/components/mediaTrack.ts\nfunction setupMediaTrack(trackIdentifier) {\n  const initialPub = getTrackByIdentifier(trackIdentifier);\n  const trackObserver = observeParticipantMedia(trackIdentifier.participant).pipe(map2(() => {\n    return getTrackByIdentifier(trackIdentifier);\n  }), startWith2(initialPub));\n  const className = prefixClass(trackIdentifier.source === Track5.Source.Camera || trackIdentifier.source === Track5.Source.ScreenShare ? \"participant-media-video\" : \"participant-media-audio\");\n  return {\n    className,\n    trackObserver\n  };\n}\nfunction getTrackByIdentifier(options) {\n  if (isTrackReference(options)) {\n    return options.publication;\n  } else {\n    const {\n      source,\n      name,\n      participant\n    } = options;\n    if (source && name) {\n      return participant.getTracks().find(pub => pub.source === source && pub.trackName === name);\n    } else if (name) {\n      return participant.getTrackByName(name);\n    } else if (source) {\n      return participant.getTrack(source);\n    } else {\n      throw new Error(\"At least one of source and name needs to be defined\");\n    }\n  }\n}\n\n// src/observables/participant.ts\nfunction observeParticipantEvents(participant) {\n  for (var _len3 = arguments.length, events = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    events[_key3 - 1] = arguments[_key3];\n  }\n  const observable = new Observable2(subscribe => {\n    const onParticipantUpdate = () => {\n      subscribe.next(participant);\n    };\n    events.forEach(evt => {\n      participant.on(evt, onParticipantUpdate);\n    });\n    const unsubscribe = () => {\n      events.forEach(evt => {\n        participant.off(evt, onParticipantUpdate);\n      });\n    };\n    return unsubscribe;\n  }).pipe(startWith3(participant));\n  return observable;\n}\nfunction observeParticipantMedia(participant) {\n  const participantObserver = observeParticipantEvents(participant, ParticipantEvent2.TrackMuted, ParticipantEvent2.TrackUnmuted, ParticipantEvent2.ParticipantPermissionsChanged,\n  // ParticipantEvent.IsSpeakingChanged,\n  ParticipantEvent2.TrackPublished, ParticipantEvent2.TrackUnpublished, ParticipantEvent2.LocalTrackPublished, ParticipantEvent2.LocalTrackUnpublished, ParticipantEvent2.MediaDevicesError, ParticipantEvent2.TrackSubscriptionStatusChanged\n  // ParticipantEvent.ConnectionQualityChanged,\n  ).pipe(map3(p => {\n    const {\n      isMicrophoneEnabled,\n      isCameraEnabled,\n      isScreenShareEnabled\n    } = p;\n    const microphoneTrack = p.getTrack(Track6.Source.Microphone);\n    const cameraTrack = p.getTrack(Track6.Source.Camera);\n    const participantMedia = {\n      isCameraEnabled,\n      isMicrophoneEnabled,\n      isScreenShareEnabled,\n      cameraTrack,\n      microphoneTrack,\n      participant: p\n    };\n    return participantMedia;\n  }));\n  return participantObserver;\n}\nfunction createTrackObserver(participant, options) {\n  return observeParticipantMedia(participant).pipe(map3(() => {\n    return {\n      publication: getTrackByIdentifier(options)\n    };\n  }));\n}\nfunction participantInfoObserver(participant) {\n  const observer = observeParticipantEvents(participant, ParticipantEvent2.ParticipantMetadataChanged\n  // ParticipantEvent.LocalTrackPublished,\n  ).pipe(map3(_ref15 => {\n    let {\n      name,\n      identity,\n      metadata\n    } = _ref15;\n    return {\n      name,\n      identity,\n      metadata\n    };\n  }), startWith3({\n    name: participant.name,\n    identity: participant.identity,\n    metadata: participant.metadata\n  }));\n  return observer;\n}\nfunction createConnectionQualityObserver(participant) {\n  const observer = participantEventSelector(participant, ParticipantEvent2.ConnectionQualityChanged).pipe(map3(_ref16 => {\n    let [quality] = _ref16;\n    return quality;\n  }), startWith3(participant.connectionQuality));\n  return observer;\n}\nfunction participantEventSelector(participant, event) {\n  const observable = new Observable2(subscribe => {\n    const update = function () {\n      for (var _len4 = arguments.length, params = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        params[_key4] = arguments[_key4];\n      }\n      subscribe.next(params);\n    };\n    participant.on(event, update);\n    const unsubscribe = () => {\n      participant.off(event, update);\n    };\n    return unsubscribe;\n  });\n  return observable;\n}\nfunction mutedObserver(trackRef) {\n  var _a, _b, _c, _d;\n  return observeParticipantEvents(trackRef.participant, ParticipantEvent2.TrackMuted, ParticipantEvent2.TrackUnmuted, ParticipantEvent2.TrackSubscribed, ParticipantEvent2.TrackUnsubscribed, ParticipantEvent2.LocalTrackPublished, ParticipantEvent2.LocalTrackUnpublished).pipe(map3(participant => {\n    var _a2, _b2;\n    const pub = (_a2 = trackRef.publication) != null ? _a2 : participant.getTrack(trackRef.source);\n    return (_b2 = pub == null ? void 0 : pub.isMuted) != null ? _b2 : true;\n  }), startWith3((_d = (_c = (_a = trackRef.publication) == null ? void 0 : _a.isMuted) != null ? _c : (_b = trackRef.participant.getTrack(trackRef.source)) == null ? void 0 : _b.isMuted) != null ? _d : true));\n}\nfunction createIsSpeakingObserver(participant) {\n  return participantEventSelector(participant, ParticipantEvent2.IsSpeakingChanged).pipe(map3(_ref17 => {\n    let [isSpeaking] = _ref17;\n    return isSpeaking;\n  }));\n}\nfunction connectedParticipantsObserver(room) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _a;\n  let subscriber;\n  const observable = new Observable2(sub => {\n    subscriber = sub;\n    return () => listener.unsubscribe();\n  }).pipe(startWith3(Array.from(room.participants.values())));\n  const additionalRoomEvents = (_a = options.additionalRoomEvents) != null ? _a : allParticipantRoomEvents;\n  const roomEvents = Array.from(/* @__PURE__ */new Set([RoomEvent3.ParticipantConnected, RoomEvent3.ParticipantDisconnected, RoomEvent3.ConnectionStateChanged, ...additionalRoomEvents]));\n  const listener = observeRoomEvents(room, ...roomEvents).subscribe(r => subscriber == null ? void 0 : subscriber.next(Array.from(r.participants.values())));\n  if (room.participants.size > 0) {\n    subscriber == null ? void 0 : subscriber.next(Array.from(room.participants.values()));\n  }\n  return observable;\n}\nfunction connectedParticipantObserver(room, identity) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _a;\n  const additionalEvents = (_a = options.additionalEvents) != null ? _a : allParticipantEvents;\n  const observable = observeRoomEvents(room, RoomEvent3.ParticipantConnected, RoomEvent3.ParticipantDisconnected, RoomEvent3.ConnectionStateChanged).pipe(switchMap(r => {\n    const participant = r.getParticipantByIdentity(identity);\n    if (participant) {\n      return observeParticipantEvents(participant, ...additionalEvents);\n    } else {\n      return new Observable2(subscribe => subscribe.next(void 0));\n    }\n  }), startWith3(room.getParticipantByIdentity(identity)));\n  return observable;\n}\nfunction participantPermissionObserver(participant) {\n  const observer = participantEventSelector(participant, ParticipantEvent2.ParticipantPermissionsChanged).pipe(map3(() => participant.permissions), startWith3(participant.permissions));\n  return observer;\n}\n\n// src/components/mediaToggle.ts\nfunction setupMediaToggle(source, room, options) {\n  const {\n    localParticipant\n  } = room;\n  const getSourceEnabled = (source2, localParticipant2) => {\n    let isEnabled = false;\n    switch (source2) {\n      case Track7.Source.Camera:\n        isEnabled = localParticipant2.isCameraEnabled;\n        break;\n      case Track7.Source.Microphone:\n        isEnabled = localParticipant2.isMicrophoneEnabled;\n        break;\n      case Track7.Source.ScreenShare:\n        isEnabled = localParticipant2.isScreenShareEnabled;\n        break;\n      default:\n        break;\n    }\n    return isEnabled;\n  };\n  const enabledObserver = observeParticipantMedia(localParticipant).pipe(map4(media => {\n    return getSourceEnabled(source, media.participant);\n  }), startWith4(getSourceEnabled(source, localParticipant)));\n  const pendingSubject = new Subject2();\n  const toggle = (forceState, captureOptions) => __async(this, null, function* () {\n    try {\n      captureOptions != null ? captureOptions : captureOptions = options;\n      pendingSubject.next(true);\n      switch (source) {\n        case Track7.Source.Camera:\n          yield localParticipant.setCameraEnabled(forceState != null ? forceState : !localParticipant.isCameraEnabled, captureOptions);\n          break;\n        case Track7.Source.Microphone:\n          yield localParticipant.setMicrophoneEnabled(forceState != null ? forceState : !localParticipant.isMicrophoneEnabled, captureOptions);\n          break;\n        case Track7.Source.ScreenShare:\n          yield localParticipant.setScreenShareEnabled(forceState != null ? forceState : !localParticipant.isScreenShareEnabled, captureOptions);\n          break;\n        default:\n          break;\n      }\n    } finally {\n      pendingSubject.next(false);\n    }\n  });\n  const className = prefixClass(\"button\");\n  return {\n    className,\n    toggle,\n    enabledObserver,\n    pendingObserver: pendingSubject.asObservable()\n  };\n}\nfunction setupManualToggle() {\n  let state = false;\n  const enabledSubject = new Subject2();\n  const pendingSubject = new Subject2();\n  const toggle = forceState => __async(this, null, function* () {\n    pendingSubject.next(true);\n    state = forceState != null ? forceState : !state;\n    enabledSubject.next(state);\n    pendingSubject.next(false);\n  });\n  const className = prefixClass(\"button\");\n  return {\n    className,\n    toggle,\n    enabledObserver: enabledSubject.asObservable(),\n    pendingObserver: pendingSubject.asObservable()\n  };\n}\n\n// src/components/mediaDeviceSelect.ts\nimport { Track as Track8 } from \"livekit-client\";\nimport { BehaviorSubject } from \"rxjs\";\nfunction setupDeviceSelector(kind, room, localTrack) {\n  var _this = this;\n  const activeDeviceSubject = new BehaviorSubject(void 0);\n  const activeDeviceObservable = room ? createActiveDeviceObservable(room, kind) : activeDeviceSubject.asObservable();\n  const setActiveMediaDevice = function (_0) {\n    for (var _len5 = arguments.length, _1 = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      _1[_key5 - 1] = arguments[_key5];\n    }\n    return __async(_this, [_0, ..._1], function (id) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return function* () {\n        var _a, _b, _c;\n        if (room) {\n          log.debug(`Switching active device of kind \"${kind}\" with id ${id}.`);\n          yield room.switchActiveDevice(kind, id, options.exact);\n          const actualDeviceId = (_a = room.getActiveDevice(kind)) != null ? _a : id;\n          if (actualDeviceId !== id && id !== \"default\") {\n            log.info(`We tried to select the device with id (${id}), but the browser decided to select the device with id (${actualDeviceId}) instead.`);\n          }\n          let targetTrack = void 0;\n          if (kind === \"audioinput\") targetTrack = (_b = room.localParticipant.getTrack(Track8.Source.Microphone)) == null ? void 0 : _b.track;else if (kind === \"videoinput\") {\n            targetTrack = (_c = room.localParticipant.getTrack(Track8.Source.Camera)) == null ? void 0 : _c.track;\n          }\n          const useDefault = id === \"default\" && !targetTrack || id === \"default\" && (targetTrack == null ? void 0 : targetTrack.mediaStreamTrack.label.startsWith(\"Default\"));\n          activeDeviceSubject.next(useDefault ? id : actualDeviceId);\n        } else if (localTrack) {\n          yield localTrack.setDeviceId(options.exact ? {\n            exact: id\n          } : id);\n          const actualId = yield localTrack.getDeviceId();\n          activeDeviceSubject.next(id === \"default\" && localTrack.mediaStreamTrack.label.startsWith(\"Default\") ? id : actualId);\n        } else if (activeDeviceSubject.value !== id) {\n          log.warn(\"device switch skipped, please provide either a room or a local track to switch on. \");\n          activeDeviceSubject.next(id);\n        }\n      }();\n    });\n  };\n  const className = prefixClass(\"media-device-select\");\n  return {\n    className,\n    activeDeviceObservable,\n    setActiveMediaDevice\n  };\n}\n\n// src/components/disconnectButton.ts\nfunction setupDisconnectButton(room) {\n  const disconnect = stopTracks => {\n    room.disconnect(stopTracks);\n  };\n  const className = prefixClass(\"disconnect-button\");\n  return {\n    className,\n    disconnect\n  };\n}\n\n// src/components/connectionQualityIndicator.ts\nfunction setupConnectionQualityIndicator(participant) {\n  const className = prefixClass(\"connection-quality\");\n  const connectionQualityObserver = createConnectionQualityObserver(participant);\n  return {\n    className,\n    connectionQualityObserver\n  };\n}\n\n// src/components/trackMutedIndicator.ts\nimport { Track as Track9 } from \"livekit-client\";\nfunction setupTrackMutedIndicator(trackRef) {\n  let classForSource = \"track-muted-indicator-camera\";\n  switch (trackRef.source) {\n    case Track9.Source.Camera:\n      classForSource = \"track-muted-indicator-camera\";\n      break;\n    case Track9.Source.Microphone:\n      classForSource = \"track-muted-indicator-microphone\";\n      break;\n    default:\n      break;\n  }\n  const className = prefixClass(classForSource);\n  const mediaMutedObserver = mutedObserver(trackRef);\n  return {\n    className,\n    mediaMutedObserver\n  };\n}\n\n// src/components/participantName.ts\nfunction setupParticipantName(participant) {\n  const infoObserver = participantInfoObserver(participant);\n  return {\n    className: \"lk-participant-name\",\n    infoObserver\n  };\n}\n\n// src/components/participantTile.ts\nfunction setupParticipantTile() {\n  const className = prefixClass(\"participant-tile\");\n  return {\n    className\n  };\n}\n\n// src/components/chat.ts\nimport { DataPacket_Kind as DataPacket_Kind2, RoomEvent as RoomEvent4 } from \"livekit-client\";\nimport { BehaviorSubject as BehaviorSubject2, Subject as Subject3, scan, map as map6, takeUntil } from \"rxjs\";\n\n// src/observables/dataChannel.ts\nimport { DataPacket_Kind } from \"livekit-client\";\nimport { Observable as Observable3, filter as filter2, map as map5 } from \"rxjs\";\nvar DataTopic = {\n  CHAT: \"lk-chat-topic\"\n};\nfunction sendMessage(_0, _1, _2) {\n  return __async(this, arguments, function (localParticipant, payload, topic) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    return function* () {\n      const {\n        kind,\n        destination\n      } = options;\n      yield localParticipant.publishData(payload, kind != null ? kind : DataPacket_Kind.RELIABLE, {\n        destination,\n        topic\n      });\n    }();\n  });\n}\nfunction setupDataMessageHandler(room, topic, onMessage) {\n  var _this2 = this;\n  const messageObservable = createDataObserver(room).pipe(filter2(_ref18 => {\n    let [,,, messageTopic] = _ref18;\n    return topic === void 0 || messageTopic === topic;\n  }), map5(_ref19 => {\n    let [payload, participant,, messageTopic] = _ref19;\n    const msg = {\n      payload,\n      topic: messageTopic,\n      from: participant\n    };\n    onMessage == null ? void 0 : onMessage(msg);\n    return msg;\n  }));\n  let isSendingSubscriber;\n  const isSendingObservable = new Observable3(subscriber => {\n    isSendingSubscriber = subscriber;\n  });\n  const send = function (_0) {\n    for (var _len6 = arguments.length, _1 = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n      _1[_key6 - 1] = arguments[_key6];\n    }\n    return __async(_this2, [_0, ..._1], function (payload) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return function* () {\n        isSendingSubscriber.next(true);\n        try {\n          yield sendMessage(room.localParticipant, payload, topic, options);\n        } finally {\n          isSendingSubscriber.next(false);\n        }\n      }();\n    });\n  };\n  return {\n    messageObservable,\n    isSendingObservable,\n    send\n  };\n}\n\n// src/components/chat.ts\nvar encoder = new TextEncoder();\nvar decoder = new TextDecoder();\nvar topicSubjectMap = /* @__PURE__ */new Map();\nvar encode = message => encoder.encode(JSON.stringify({\n  message: message.message,\n  timestamp: message.timestamp\n}));\nvar decode = message => JSON.parse(decoder.decode(message));\nfunction setupChat(room, options) {\n  var _a, _b;\n  const onDestroyObservable = new Subject3();\n  const {\n    messageDecoder,\n    messageEncoder,\n    channelTopic\n  } = options != null ? options : {};\n  const topic = channelTopic != null ? channelTopic : DataTopic.CHAT;\n  let needsSetup = false;\n  if (!topicSubjectMap.has(room)) {\n    needsSetup = true;\n  }\n  const topicMap = (_a = topicSubjectMap.get(room)) != null ? _a : /* @__PURE__ */new Map();\n  const messageSubject = (_b = topicMap.get(topic)) != null ? _b : new Subject3();\n  topicMap.set(topic, messageSubject);\n  topicSubjectMap.set(room, topicMap);\n  if (needsSetup) {\n    const {\n      messageObservable\n    } = setupDataMessageHandler(room, topic);\n    messageObservable.pipe(takeUntil(onDestroyObservable)).subscribe(messageSubject);\n  }\n  const finalMessageDecoder = messageDecoder != null ? messageDecoder : decode;\n  const messagesObservable = messageSubject.pipe(map6(msg => {\n    const parsedMessage = finalMessageDecoder(msg.payload);\n    const newMessage = __spreadProps(__spreadValues({}, parsedMessage), {\n      from: msg.from\n    });\n    return newMessage;\n  }), scan((acc, value) => [...acc, value], []), takeUntil(onDestroyObservable));\n  const isSending$ = new BehaviorSubject2(false);\n  const finalMessageEncoder = messageEncoder != null ? messageEncoder : encode;\n  const send = message => __async(this, null, function* () {\n    const timestamp = Date.now();\n    const encodedMsg = finalMessageEncoder({\n      message,\n      timestamp\n    });\n    isSending$.next(true);\n    try {\n      yield sendMessage(room.localParticipant, encodedMsg, topic, {\n        kind: DataPacket_Kind2.RELIABLE\n      });\n      messageSubject.next({\n        payload: encodedMsg,\n        topic,\n        from: room.localParticipant\n      });\n    } finally {\n      isSending$.next(false);\n    }\n  });\n  function destroy() {\n    onDestroyObservable.next();\n    onDestroyObservable.complete();\n    topicSubjectMap.clear();\n  }\n  room.once(RoomEvent4.Disconnected, destroy);\n  return {\n    messageObservable: messagesObservable,\n    isSendingObservable: isSending$,\n    send\n  };\n}\n\n// src/components/startAudio.ts\nfunction setupStartAudio() {\n  const handleStartAudioPlayback = room => __async(this, null, function* () {\n    log.info(\"Start Audio for room: \", room);\n    yield room.startAudio();\n  });\n  const className = prefixClass(\"start-audio-button\");\n  return {\n    className,\n    roomAudioPlaybackAllowedObservable,\n    handleStartAudioPlayback\n  };\n}\n\n// src/components/startVideo.ts\nfunction setupStartVideo() {\n  const handleStartVideoPlayback = room => __async(this, null, function* () {\n    log.info(\"Start Video for room: \", room);\n    yield room.startVideo();\n  });\n  const className = prefixClass(\"start-audio-button\");\n  return {\n    className,\n    roomVideoPlaybackAllowedObservable,\n    handleStartVideoPlayback\n  };\n}\n\n// src/components/chatToggle.ts\nfunction setupChatToggle() {\n  const className = [prefixClass(\"button\"), prefixClass(\"chat-toggle\")].join(\" \");\n  return {\n    className\n  };\n}\n\n// src/components/focusToggle.ts\nfunction setupFocusToggle() {\n  const className = [prefixClass(\"button\"), prefixClass(\"focus-toggle-button\")].join(\" \");\n  return {\n    className\n  };\n}\n\n// src/components/clearPinButton.ts\nfunction setupClearPinButton() {\n  const className = \"lk-clear-pin-button lk-button\";\n  return {\n    className\n  };\n}\n\n// src/components/room.ts\nfunction setupLiveKitRoom() {\n  const className = \"lk-room-container\";\n  return {\n    className\n  };\n}\n\n// src/observables/track.ts\nimport { RoomEvent as RoomEvent5, TrackEvent } from \"livekit-client\";\nimport { map as map7, Observable as Observable4, startWith as startWith5 } from \"rxjs\";\nfunction trackObservable(track) {\n  const trackObserver = observeTrackEvents(track, TrackEvent.Muted, TrackEvent.Unmuted, TrackEvent.Subscribed, TrackEvent.Unsubscribed);\n  return trackObserver;\n}\nfunction observeTrackEvents(track) {\n  for (var _len7 = arguments.length, events = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n    events[_key7 - 1] = arguments[_key7];\n  }\n  const observable = new Observable4(subscribe => {\n    const onTrackUpdate = () => {\n      subscribe.next(track);\n    };\n    events.forEach(evt => {\n      track.on(evt, onTrackUpdate);\n    });\n    const unsubscribe = () => {\n      events.forEach(evt => {\n        track.off(evt, onTrackUpdate);\n      });\n    };\n    return unsubscribe;\n  }).pipe(startWith5(track));\n  return observable;\n}\nfunction getTrackReferences(room, sources) {\n  let onlySubscribedTracks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  const localParticipant = room.localParticipant;\n  const allParticipants = [localParticipant, ...Array.from(room.participants.values())];\n  const trackReferences = [];\n  allParticipants.forEach(participant => {\n    sources.forEach(source => {\n      const sourceReferences = Array.from(participant.tracks.values()).filter(track => track.source === source && (\n      // either return all or only the ones that are subscribed\n      !onlySubscribedTracks || track.track)).map(track => {\n        return {\n          participant,\n          publication: track,\n          source: track.source\n        };\n      });\n      trackReferences.push(...sourceReferences);\n    });\n  });\n  return {\n    trackReferences,\n    participants: allParticipants\n  };\n}\nfunction trackReferencesObservable(room, sources, options) {\n  var _a, _b;\n  const additionalRoomEvents = (_a = options.additionalRoomEvents) != null ? _a : allParticipantRoomEvents;\n  const onlySubscribedTracks = (_b = options.onlySubscribed) != null ? _b : true;\n  const roomEvents = Array.from((/* @__PURE__ */new Set([RoomEvent5.ParticipantConnected, RoomEvent5.ParticipantDisconnected, RoomEvent5.ConnectionStateChanged, RoomEvent5.LocalTrackPublished, RoomEvent5.LocalTrackUnpublished, RoomEvent5.TrackPublished, RoomEvent5.TrackUnpublished, RoomEvent5.TrackSubscriptionStatusChanged, ...additionalRoomEvents])).values());\n  const observable = observeRoomEvents(room, ...roomEvents).pipe(map7(room2 => {\n    const data = getTrackReferences(room2, sources, onlySubscribedTracks);\n    log.debug(`TrackReference[] was updated. (length ${data.trackReferences.length})`, data);\n    return data;\n  }), startWith5(getTrackReferences(room, sources, onlySubscribedTracks)));\n  return observable;\n}\n\n// src/observables/dom-event.ts\nimport { concat as concat2, distinctUntilChanged, fromEvent, map as map8, of, skipUntil, timeout } from \"rxjs\";\nfunction createInteractingObservable(htmlElement) {\n  let inactiveAfter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e3;\n  if (htmlElement === null) return of(false);\n  const move$ = fromEvent(htmlElement, \"mousemove\", {\n    passive: true\n  }).pipe(map8(() => true));\n  const moveAndStop$ = move$.pipe(timeout({\n    each: inactiveAfter,\n    with: () => concat2(of(false), moveAndStop$.pipe(skipUntil(move$)))\n  }), distinctUntilChanged());\n  return moveAndStop$;\n}\n\n// src/persistent-storage/local-storage-helpers.ts\nfunction saveToLocalStorage(key, value) {\n  if (typeof localStorage === \"undefined\") {\n    log.error(\"Local storage is not available.\");\n    return;\n  }\n  try {\n    localStorage.setItem(key, JSON.stringify(value));\n  } catch (error) {\n    log.error(`Error setting item to local storage: ${error}`);\n  }\n}\nfunction loadFromLocalStorage(key) {\n  if (typeof localStorage === \"undefined\") {\n    log.error(\"Local storage is not available.\");\n    return void 0;\n  }\n  try {\n    const item = localStorage.getItem(key);\n    if (!item) {\n      log.warn(`Item with key ${key} does not exist in local storage.`);\n      return void 0;\n    }\n    return JSON.parse(item);\n  } catch (error) {\n    log.error(`Error getting item from local storage: ${error}`);\n    return void 0;\n  }\n}\nfunction createLocalStorageInterface(key) {\n  return {\n    load: () => loadFromLocalStorage(key),\n    save: value => saveToLocalStorage(key, value)\n  };\n}\n\n// src/persistent-storage/user-choices.ts\nvar USER_CHOICES_KEY = `${cssPrefix}-user-choices`;\nvar defaultUserChoices = {\n  videoEnabled: true,\n  audioEnabled: true,\n  videoDeviceId: \"\",\n  audioDeviceId: \"\",\n  username: \"\",\n  e2ee: false,\n  sharedPassphrase: \"\"\n};\nvar {\n  load,\n  save\n} = createLocalStorageInterface(USER_CHOICES_KEY);\nfunction saveUserChoices(userChoices) {\n  let preventSave = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (preventSave === true) {\n    return;\n  }\n  const _a = userChoices,\n    {\n      e2ee,\n      sharedPassphrase\n    } = _a,\n    toSave = __objRest(_a, [\"e2ee\", \"sharedPassphrase\"]);\n  save(toSave);\n}\nfunction loadUserChoices(defaults) {\n  let preventLoad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var _a, _b, _c, _d, _e, _f, _g;\n  const fallback = {\n    videoEnabled: (_a = defaults == null ? void 0 : defaults.videoEnabled) != null ? _a : defaultUserChoices.videoEnabled,\n    audioEnabled: (_b = defaults == null ? void 0 : defaults.audioEnabled) != null ? _b : defaultUserChoices.audioEnabled,\n    videoDeviceId: (_c = defaults == null ? void 0 : defaults.videoDeviceId) != null ? _c : defaultUserChoices.videoDeviceId,\n    audioDeviceId: (_d = defaults == null ? void 0 : defaults.audioDeviceId) != null ? _d : defaultUserChoices.audioDeviceId,\n    username: (_e = defaults == null ? void 0 : defaults.username) != null ? _e : defaultUserChoices.username,\n    e2ee: (_f = defaults == null ? void 0 : defaults.e2ee) != null ? _f : defaultUserChoices.e2ee,\n    sharedPassphrase: (_g = defaults == null ? void 0 : defaults.sharedPassphrase) != null ? _g : defaultUserChoices.sharedPassphrase\n  };\n  if (preventLoad) {\n    return fallback;\n  } else {\n    const maybeLoadedObject = load();\n    const result = __spreadValues(__spreadValues({}, fallback), maybeLoadedObject != null ? maybeLoadedObject : {});\n    return result;\n  }\n}\nexport { DataTopic, GRID_LAYOUTS, PIN_DEFAULT_STATE, WIDGET_DEFAULT_STATE, activeSpeakerObserver, allParticipantEvents, allParticipantRoomEvents, allRemoteParticipantEvents, allRemoteParticipantRoomEvents, attachIfSubscribed, computeMenuPosition, connectedParticipantObserver, connectedParticipantsObserver, connectionStateObserver, createActiveDeviceObservable, createConnectionQualityObserver, createDataObserver, createDefaultGrammar, createEmailRegExp, createInteractingObservable, createIsSpeakingObserver, createMediaDeviceObserver, createTrackObserver, createUrlRegExp, cssPrefix, encryptionStatusObservable, getScrollBarWidth, getTrackByIdentifier, getTrackReferenceId, getTrackReferenceSource, isEqualTrackRef, isLocal, isMobileBrowser, isParticipantSourcePinned, isParticipantTrackReferencePinned, isPlaceholderReplacement, isRemote, isSourceWitOptions, isSourcesWithOptions, isTrackReference, isTrackReferencePinned, isTrackReferencePlaceholder, isWeb, loadUserChoices, log, mutedObserver, observeParticipantEvents, observeParticipantMedia, observeRoomEvents, observeTrackEvents, participantEventSelector, participantInfoObserver, participantPermissionObserver, roomAudioPlaybackAllowedObservable, roomEventSelector, roomInfoObserver, roomObserver, roomVideoPlaybackAllowedObservable, saveUserChoices, screenShareObserver, selectGridLayout, sendMessage, setDifference, setLogExtension, setLogLevel, setupChat, setupChatToggle, setupClearPinButton, setupConnectionQualityIndicator, setupDataMessageHandler, setupDeviceSelector, setupDisconnectButton, setupFocusToggle, setupLiveKitRoom, setupManualToggle, setupMediaToggle, setupMediaTrack, setupParticipantName, setupParticipantTile, setupStartAudio, setupStartVideo, setupTrackMutedIndicator, sortParticipants, sortTrackReferences, supportsScreenSharing, tokenize, trackObservable, trackReferencesObservable, updatePages, wasClickOutside };","map":{"version":3,"names":["cssPrefix","LocalParticipant","RemoteParticipant","isTrackReference","trackReference","isTrackReferenceSubscribed","isTrackReferencePublished","_a","hasOwnProperty","publication","track","isTrackReferencePlaceholder","getTrackReferenceId","participant","identity","source","trackSid","Error","getTrackReferenceSource","isEqualTrackRef","a","b","isTrackReferencePinned","pinState","some","pinnedTrackReference","isPlaceholderReplacement","currentTrackRef","nextTrackRef","isLocal","p","isRemote","attachIfSubscribed","element","isSubscribed","attach","detach","isParticipantSourcePinned","_ref","pinnedSource","pinnedParticipant","isParticipantTrackReferencePinned","trackRef","pinnedTrackRef","getScrollBarWidth","inner","document","createElement","style","width","height","outer","position","top","left","visibility","overflow","appendChild","body","w1","offsetWidth","w2","clientWidth","removeChild","scrollBarWidth","isWeb","isMobileBrowser","test","window","navigator","userAgent","createUrlRegExp","options","__spreadValues","protocol","auth","ip","RegExp","host","domain","tld","port","path","regex","exact","createEmailRegExp","computePosition","flip","offset","shift","computeMenuPosition","button","menu","__async","x","y","placement","middleware","padding","wasClickOutside","insideElement","event","isOutside","contains","target","createDefaultGrammar","email","url","tokenize","input","grammar","matches","Object","entries","map","_ref2","weight","type","rx","Array","from","matchAll","_ref3","index","content","flat","sort","d","filter","_ref4","i","arr","prev","length","tokens","pos","push","substring","ParticipantEvent","RoomEvent","allRemoteParticipantRoomEvents","ConnectionStateChanged","RoomMetadataChanged","ActiveSpeakersChanged","ConnectionQualityChanged","ParticipantConnected","ParticipantDisconnected","ParticipantPermissionsChanged","ParticipantMetadataChanged","TrackMuted","TrackUnmuted","TrackPublished","TrackUnpublished","TrackStreamStateChanged","TrackSubscriptionFailed","TrackSubscriptionPermissionChanged","TrackSubscriptionStatusChanged","allParticipantRoomEvents","LocalTrackPublished","LocalTrackUnpublished","allRemoteParticipantEvents","IsSpeakingChanged","allParticipantEvents","setLogLevel","setClientSdkLogLevel","setLogExtension","setClientSdkLogExtension","LogLevel","LogLevelEnum","loglevel","log","getLogger","setDefaultLevel","level","arguments","undefined","setLevel","liveKitClientLogLevel","extension","originalFactory","methodFactory","methodName","configLevel","loggerName","rawMethod","logLevel","needLog","silent","msg","context","getLevel","liveKitClientLogExtension","GRID_LAYOUTS","columns","rows","name","minTiles","maxTiles","minWidth","minHeight","selectGridLayout","layouts","participantCount","currentLayoutIndex","layout","find","layout_","allLayouts","isBiggerLayoutAvailable","findIndex","l","layoutIsBiggerThanCurrent","layoutFitsSameAmountOfParticipants","warn","smallerLayout","slice","setDifference","setA","setB","_difference","Set","elem","delete","supportsScreenSharing","mediaDevices","getDisplayMedia","PIN_DEFAULT_STATE","WIDGET_DEFAULT_STATE","showChat","unreadMessages","isSourceWitOptions","isSourcesWithOptions","sources","isArray","Track","Track2","sortParticipantsByAudioLevel","audioLevel","sortParticipantsByIsSpeaking","isSpeaking","sortParticipantsByLastSpokenAT","_b","_c","_d","lastSpokeAt","getTime","sortParticipantsByJoinedAt","joinedAt","sortTrackReferencesByType","sortTrackRefsByIsCameraEnabled","aVideo","isCameraEnabled","bVideo","sortTrackReferences","tracks","localTracks","screenShareTracks","cameraTracks","undefinedTracks","forEach","Source","Camera","ScreenShare","sortedScreenShareTracks","sortScreenShareTracks","sortedCameraTracks","sortCameraTracks","localScreenShares","remoteScreenShares","sortedScreenShareTrackRefs","cameraTrackReferences","localCameraTracks","remoteCameraTracks","LocalParticipant2","sortParticipants","participants","sortedParticipants","videoTracks","size","localParticipant","localIdx","indexOf","splice","chunk","reduce","item","idx","zip","a1","a2","resultLength","Math","max","fill","_val","differenceBy","by","c","v","includes","Participant","Track3","TrackPublication","flatTrackReferenceArray","list","visualPageChange","state","next","dropped","added","listNeedsUpdating","changes","trackReferences","indexToReplace","trackReference_","swapItems","moveForward","moveBack","indexReplaceWith","dropItem","itemToDrop","indexOfElementToDrop","addItem","itemToAdd","divideIntoPages","maxElementsOnPage","pages","updatePages","currentList","nextList","maxItemsOnPage","updatedList","refreshList","addedItems","currentPages","nextPages","_ref5","pageIndex","currentPage","nextPage","updatedPage","debug","_ref6","missingItems","currentItem","updateForCurrentItem","newItem_","Track7","Subject","Subject2","map4","startWith","startWith4","ParticipantEvent2","RoomEvent3","Track6","map3","switchMap","Observable","Observable2","startWith3","finalize","concat","LocalParticipant3","Room","RoomEvent2","Track4","observeRoomEvents","room","_len","events","_key","observable","subscribe","onRoomUpdate","evt","on","unsubscribe","off","pipe","roomEventSelector","update","_len2","params","_key2","roomObserver","TrackSubscribed","TrackUnsubscribed","AudioPlaybackStatusChanged","connectionStateObserver","_ref7","connectionState","screenShareObserver","screenShareSubscriber","observers","subscriber","observer","handleSub","ScreenShareAudio","trackMap","tr","getScreenShareTracks","participant2","getTracks","_ref8","args","_ref9","setTimeout","values","roomInfoObserver","r","metadata","activeSpeakerObserver","_ref10","speakers","createMediaDeviceObserver","kind","onError","requestPermissions","onDeviceChange","newDevices","getLocalDevices","deviceSubject","e","_a2","removeEventListener","isSecureContext","addEventListener","catch","createDataObserver","DataReceived","roomAudioPlaybackAllowedObservable","room2","canPlayAudio","canPlaybackAudio","roomVideoPlaybackAllowedObservable","VideoPlaybackStatusChanged","canPlayVideo","canPlaybackVideo","createActiveDeviceObservable","ActiveDeviceChanged","_ref11","kindOfDevice","_ref12","kind2","deviceId","getActiveDevice","encryptionStatusObservable","ParticipantEncryptionStatusChanged","_ref13","_ref14","encrypted","isE2EEEnabled","isEncrypted","Track5","map2","startWith2","prefixClass","unprefixedClassName","setupMediaTrack","trackIdentifier","initialPub","getTrackByIdentifier","trackObserver","observeParticipantMedia","className","pub","trackName","getTrackByName","getTrack","observeParticipantEvents","_len3","_key3","onParticipantUpdate","participantObserver","MediaDevicesError","isMicrophoneEnabled","isScreenShareEnabled","microphoneTrack","Microphone","cameraTrack","participantMedia","createTrackObserver","participantInfoObserver","_ref15","createConnectionQualityObserver","participantEventSelector","_ref16","quality","connectionQuality","_len4","_key4","mutedObserver","_b2","isMuted","createIsSpeakingObserver","_ref17","connectedParticipantsObserver","sub","listener","additionalRoomEvents","roomEvents","connectedParticipantObserver","additionalEvents","getParticipantByIdentity","participantPermissionObserver","permissions","setupMediaToggle","getSourceEnabled","source2","localParticipant2","isEnabled","enabledObserver","media","pendingSubject","toggle","forceState","captureOptions","setCameraEnabled","setMicrophoneEnabled","setScreenShareEnabled","pendingObserver","asObservable","setupManualToggle","enabledSubject","Track8","BehaviorSubject","setupDeviceSelector","localTrack","_this","activeDeviceSubject","activeDeviceObservable","setActiveMediaDevice","_0","_len5","_1","_key5","id","switchActiveDevice","actualDeviceId","info","targetTrack","useDefault","mediaStreamTrack","label","startsWith","setDeviceId","actualId","getDeviceId","value","setupDisconnectButton","disconnect","stopTracks","setupConnectionQualityIndicator","connectionQualityObserver","Track9","setupTrackMutedIndicator","classForSource","mediaMutedObserver","setupParticipantName","infoObserver","setupParticipantTile","DataPacket_Kind","DataPacket_Kind2","RoomEvent4","BehaviorSubject2","Subject3","scan","map6","takeUntil","Observable3","filter2","map5","DataTopic","CHAT","sendMessage","_2","payload","topic","destination","publishData","RELIABLE","setupDataMessageHandler","onMessage","_this2","messageObservable","_ref18","messageTopic","_ref19","isSendingSubscriber","isSendingObservable","send","_len6","_key6","encoder","TextEncoder","decoder","TextDecoder","topicSubjectMap","Map","encode","message","JSON","stringify","timestamp","decode","parse","setupChat","onDestroyObservable","messageDecoder","messageEncoder","channelTopic","needsSetup","has","topicMap","get","messageSubject","set","finalMessageDecoder","messagesObservable","parsedMessage","newMessage","__spreadProps","acc","isSending$","finalMessageEncoder","Date","now","encodedMsg","destroy","complete","clear","once","Disconnected","setupStartAudio","handleStartAudioPlayback","startAudio","setupStartVideo","handleStartVideoPlayback","startVideo","setupChatToggle","join","setupFocusToggle","setupClearPinButton","setupLiveKitRoom","RoomEvent5","TrackEvent","map7","Observable4","startWith5","trackObservable","observeTrackEvents","Muted","Unmuted","Subscribed","Unsubscribed","_len7","_key7","onTrackUpdate","getTrackReferences","onlySubscribedTracks","allParticipants","sourceReferences","trackReferencesObservable","onlySubscribed","data","concat2","distinctUntilChanged","fromEvent","map8","of","skipUntil","timeout","createInteractingObservable","htmlElement","inactiveAfter","move$","passive","moveAndStop$","each","with","saveToLocalStorage","key","localStorage","error","setItem","loadFromLocalStorage","getItem","createLocalStorageInterface","load","save","USER_CHOICES_KEY","defaultUserChoices","videoEnabled","audioEnabled","videoDeviceId","audioDeviceId","username","e2ee","sharedPassphrase","saveUserChoices","userChoices","preventSave","toSave","__objRest","loadUserChoices","defaults","preventLoad","_e","_f","_g","fallback","maybeLoadedObject","result"],"sources":["C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\constants.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\utils.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\track-reference\\track-reference.types.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\track-reference\\track-reference.utils.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\helper\\detectMobileBrowser.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\helper\\url-regex.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\helper\\emailRegex.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\helper\\floating-menu.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\helper\\tokenizer.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\helper\\eventGroups.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\logger.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\helper\\grid-layouts.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\helper\\set-helper.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\helper\\featureDetection.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\types.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\sorting\\sort-track-bundles.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\sorting\\base-sort-functions.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\sorting\\sort-participants.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\helper\\array-helper.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\track-reference\\test-utils.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\sorting\\tile-array-update.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\mediaToggle.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\observables\\participant.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\observables\\room.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\mediaTrack.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\styles-interface\\class-prefixer.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\mediaDeviceSelect.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\disconnectButton.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\connectionQualityIndicator.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\trackMutedIndicator.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\participantName.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\participantTile.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\chat.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\observables\\dataChannel.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\startAudio.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\startVideo.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\chatToggle.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\focusToggle.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\clearPinButton.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\components\\room.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\observables\\track.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\observables\\dom-event.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\persistent-storage\\local-storage-helpers.ts","C:\\Users\\dinhd\\Desktop\\Test\\frontend\\node_modules\\@livekit\\components-core\\src\\persistent-storage\\user-choices.ts"],"sourcesContent":["export const cssPrefix = 'lk';\n","import type { Participant, Track, TrackPublication } from 'livekit-client';\nimport { LocalParticipant, RemoteParticipant } from 'livekit-client';\n\nimport type { PinState } from './types';\nimport type { TrackReference } from './track-reference';\nimport { isEqualTrackRef } from './track-reference';\n\nexport function isLocal(p: Participant) {\n  return p instanceof LocalParticipant;\n}\n\nexport function isRemote(p: Participant) {\n  return p instanceof RemoteParticipant;\n}\n\nexport const attachIfSubscribed = (\n  publication: TrackPublication | undefined,\n  element: HTMLMediaElement | null | undefined,\n) => {\n  if (!publication) return;\n  const { isSubscribed, track } = publication;\n  if (element && track) {\n    if (isSubscribed) {\n      track.attach(element);\n    } else {\n      track.detach(element);\n    }\n  }\n};\n\n/**\n * Check if the participant track source is pinned.\n * @deprecated Use {@link isParticipantTrackReferencePinned} instead.\n */\nexport function isParticipantSourcePinned(\n  participant: Participant,\n  source: Track.Source,\n  pinState: PinState | undefined,\n): boolean {\n  if (pinState === undefined) {\n    return false;\n  }\n\n  return pinState.some(\n    ({ source: pinnedSource, participant: pinnedParticipant }) =>\n      pinnedSource === source && pinnedParticipant.identity === participant.identity,\n  );\n}\n\n/**\n * Check if the participant track reference is pinned.\n */\nexport function isParticipantTrackReferencePinned(\n  trackRef: TrackReference,\n  pinState: PinState | undefined,\n): boolean {\n  if (pinState === undefined) {\n    return false;\n  }\n\n  return pinState.some((pinnedTrackRef) => isEqualTrackRef(pinnedTrackRef, trackRef));\n}\n\n/**\n * Calculates the scrollbar width by creating two HTML elements\n * and messaging the difference.\n * @internal\n */\nexport function getScrollBarWidth() {\n  const inner = document.createElement('p');\n  inner.style.width = '100%';\n  inner.style.height = '200px';\n\n  const outer = document.createElement('div');\n  outer.style.position = 'absolute';\n  outer.style.top = '0px';\n  outer.style.left = '0px';\n  outer.style.visibility = 'hidden';\n  outer.style.width = '200px';\n  outer.style.height = '150px';\n  outer.style.overflow = 'hidden';\n  outer.appendChild(inner);\n\n  document.body.appendChild(outer);\n  const w1 = inner.offsetWidth;\n  outer.style.overflow = 'scroll';\n  let w2 = inner.offsetWidth;\n  if (w1 === w2) {\n    w2 = outer.clientWidth;\n  }\n  document.body.removeChild(outer);\n  const scrollBarWidth = w1 - w2;\n  return scrollBarWidth;\n}\n","/**\n * The TrackReference type is a logical grouping of participant publication and/or subscribed track.\n *\n */\n\nimport type { Participant, Track, TrackPublication } from 'livekit-client';\n// ## TrackReference Types\n\n/** @public */\nexport type TrackReferencePlaceholder = {\n  participant: Participant;\n  publication?: never;\n  source: Track.Source;\n};\n\n/** @public */\nexport type TrackReference = {\n  participant: Participant;\n  publication: TrackPublication;\n  source: Track.Source;\n};\n\n/** @public */\nexport type TrackReferenceOrPlaceholder = TrackReference | TrackReferencePlaceholder;\n\n// ### TrackReference Type Predicates\n/** @internal */\nexport function isTrackReference(trackReference: unknown): trackReference is TrackReference {\n  if (typeof trackReference === 'undefined') {\n    return false;\n  }\n  return (\n    isTrackReferenceSubscribed(trackReference as TrackReference) ||\n    isTrackReferencePublished(trackReference as TrackReference)\n  );\n}\n\nfunction isTrackReferenceSubscribed(trackReference?: TrackReferenceOrPlaceholder): boolean {\n  if (!trackReference) {\n    return false;\n  }\n  return (\n    trackReference.hasOwnProperty('participant') &&\n    trackReference.hasOwnProperty('source') &&\n    trackReference.hasOwnProperty('track') &&\n    typeof trackReference.publication?.track !== 'undefined'\n  );\n}\n\nfunction isTrackReferencePublished(trackReference?: TrackReferenceOrPlaceholder): boolean {\n  if (!trackReference) {\n    return false;\n  }\n  return (\n    trackReference.hasOwnProperty('participant') &&\n    trackReference.hasOwnProperty('source') &&\n    trackReference.hasOwnProperty('publication') &&\n    typeof trackReference.publication !== 'undefined'\n  );\n}\n\nexport function isTrackReferencePlaceholder(\n  trackReference?: TrackReferenceOrPlaceholder,\n): trackReference is TrackReferencePlaceholder {\n  if (!trackReference) {\n    return false;\n  }\n  return (\n    trackReference.hasOwnProperty('participant') &&\n    trackReference.hasOwnProperty('source') &&\n    typeof trackReference.publication === 'undefined'\n  );\n}\n","import type { Track } from 'livekit-client';\nimport type { PinState } from '../types';\nimport type { TrackReferenceOrPlaceholder } from './track-reference.types';\nimport { isTrackReference, isTrackReferencePlaceholder } from './track-reference.types';\n\n/**\n * Returns a id to identify the `TrackReference` or `TrackReferencePlaceholder` based on\n * participant, track source and trackSid.\n * @remarks\n * The id pattern is: `${participantIdentity}_${trackSource}_${trackSid}` for `TrackReference`\n * and `${participantIdentity}_${trackSource}_placeholder` for `TrackReferencePlaceholder`.\n */\nexport function getTrackReferenceId(trackReference: TrackReferenceOrPlaceholder | number) {\n  if (typeof trackReference === 'string' || typeof trackReference === 'number') {\n    return `${trackReference}`;\n  } else if (isTrackReferencePlaceholder(trackReference)) {\n    return `${trackReference.participant.identity}_${trackReference.source}_placeholder`;\n  } else if (isTrackReference(trackReference)) {\n    return `${trackReference.participant.identity}_${trackReference.publication.source}_${trackReference.publication.trackSid}`;\n  } else {\n    throw new Error(`Can't generate a id for the given track reference: ${trackReference}`);\n  }\n}\n\nexport type TrackReferenceId = ReturnType<typeof getTrackReferenceId>;\n\n/** Returns the Source of the TrackReference. */\nexport function getTrackReferenceSource(trackReference: TrackReferenceOrPlaceholder): Track.Source {\n  if (isTrackReference(trackReference)) {\n    return trackReference.publication.source;\n  } else {\n    return trackReference.source;\n  }\n}\n\nexport function isEqualTrackRef(\n  a?: TrackReferenceOrPlaceholder,\n  b?: TrackReferenceOrPlaceholder,\n): boolean {\n  if (a === undefined || b === undefined) {\n    return false;\n  }\n  if (isTrackReference(a) && isTrackReference(b)) {\n    return a.publication.trackSid === b.publication.trackSid;\n  } else {\n    return getTrackReferenceId(a) === getTrackReferenceId(b);\n  }\n}\n\n/**\n * Check if the `TrackReference` is pinned.\n */\nexport function isTrackReferencePinned(\n  trackReference: TrackReferenceOrPlaceholder,\n  pinState: PinState | undefined,\n): boolean {\n  if (typeof pinState === 'undefined') {\n    return false;\n  }\n  if (isTrackReference(trackReference)) {\n    return pinState.some(\n      (pinnedTrackReference) =>\n        pinnedTrackReference.participant.identity === trackReference.participant.identity &&\n        isTrackReference(pinnedTrackReference) &&\n        pinnedTrackReference.publication.trackSid === trackReference.publication.trackSid,\n    );\n  } else if (isTrackReferencePlaceholder(trackReference)) {\n    return pinState.some(\n      (pinnedTrackReference) =>\n        pinnedTrackReference.participant.identity === trackReference.participant.identity &&\n        isTrackReferencePlaceholder(pinnedTrackReference) &&\n        pinnedTrackReference.source === trackReference.source,\n    );\n  } else {\n    return false;\n  }\n}\n\n/**\n * Check if the current `currentTrackRef` is the placeholder for next `nextTrackRef`.\n * Based on the participant identity and the source.\n * @internal\n */\nexport function isPlaceholderReplacement(\n  currentTrackRef: TrackReferenceOrPlaceholder,\n  nextTrackRef: TrackReferenceOrPlaceholder,\n) {\n  // if (typeof nextTrackRef === 'number' || typeof currentTrackRef === 'number') {\n  //   return false;\n  // }\n  return (\n    isTrackReferencePlaceholder(currentTrackRef) &&\n    isTrackReference(nextTrackRef) &&\n    nextTrackRef.participant.identity === currentTrackRef.participant.identity &&\n    nextTrackRef.source === currentTrackRef.source\n  );\n}\n","/**\n * @internal\n */\nexport function isWeb(): boolean {\n  return typeof document !== 'undefined';\n}\n\n/**\n * Mobile browser detection based on `navigator.userAgent` string.\n * Defaults to returning `false` if not in a browser.\n *\n * @remarks\n * This should only be used if feature detection or other methods do not work!\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent#mobile_device_detection\n */\nexport function isMobileBrowser(): boolean {\n  return isWeb() ? /Mobi/i.test(window.navigator.userAgent) : false;\n}\n","// The MIT License (MIT)\n\n// Copyright (c) Kevin Mrtensson <kevinmartensson@gmail.com> and Diego Perini\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\ninterface RegExOptions {\n  /**\n\t\tOnly match an exact string. Useful with `RegExp#test` to check if a string is a URL.\n\t\t@default false\n\t\t*/\n  readonly exact?: boolean;\n\n  /**\n\t\tForce URLs to start with a valid protocol or `www`. If set to `false` it'll match the TLD against a list of valid [TLDs](https://github.com/stephenmathieson/node-tlds).\n\t\t@default false\n    @deprecated This option will be removed in the next major version and has already no effect.\n\t\t*/\n  readonly strict?: boolean;\n}\n\nexport function createUrlRegExp(options: RegExOptions) {\n  options = {\n    ...options,\n  };\n\n  const protocol = `(?:(?:[a-z]+:)?//)?`;\n  const auth = '(?:\\\\S+(?::\\\\S*)?@)?';\n  const ip = new RegExp(\n    '(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}',\n    'g',\n  ).source;\n  const host = '(?:(?:[a-z\\\\u00a1-\\\\uffff0-9][-_]*)*[a-z\\\\u00a1-\\\\uffff0-9]+)';\n  const domain = '(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*';\n  const tld = `(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))\\\\.?`;\n  const port = '(?::\\\\d{2,5})?';\n  const path = '(?:[/?#][^\\\\s\"]*)?';\n  const regex = `(?:${protocol}|www\\\\.)${auth}(?:localhost|${ip}|${host}${domain}${tld})${port}${path}`;\n\n  return options.exact ? new RegExp(`(?:^${regex}$)`, 'i') : new RegExp(regex, 'ig');\n}\n","import createEmailRegExp from 'email-regex';\n\nexport { createEmailRegExp };\n","import { computePosition, flip, offset, shift } from '@floating-ui/dom';\n\nexport async function computeMenuPosition(\n  button: HTMLElement,\n  menu: HTMLElement,\n): Promise<{ x: number; y: number }> {\n  const { x, y } = await computePosition(button, menu, {\n    placement: 'top',\n    middleware: [offset(6), flip(), shift({ padding: 5 })],\n  });\n  return { x, y };\n}\n\nexport function wasClickOutside(insideElement: HTMLElement, event: MouseEvent): boolean {\n  const isOutside = !insideElement.contains(event.target as Node);\n  return isOutside;\n}\n","import { createEmailRegExp } from './emailRegex';\nimport { createUrlRegExp } from './url-regex';\n\nexport type TokenizeGrammar = { [type: string]: RegExp };\n\nexport const createDefaultGrammar = () => {\n  return {\n    email: createEmailRegExp(),\n    url: createUrlRegExp({}),\n  } satisfies TokenizeGrammar;\n};\n\nexport function tokenize<T extends TokenizeGrammar>(input: string, grammar: T) {\n  const matches = Object.entries(grammar)\n    .map(([type, rx], weight) =>\n      Array.from(input.matchAll(rx)).map(({ index, 0: content }) => ({\n        type: type as keyof T,\n        weight,\n        content,\n        index: index ?? 0,\n      })),\n    )\n    .flat()\n    .sort((a, b) => {\n      const d = a.index - b.index;\n      return d !== 0 ? d : a.weight - b.weight;\n    })\n    .filter(({ index }, i, arr) => {\n      if (i === 0) return true;\n      const prev = arr[i - 1];\n      return prev.index + prev.content.length <= index;\n    });\n\n  const tokens = [];\n  let pos = 0;\n  for (const { type, content, index } of matches) {\n    if (index > pos) tokens.push(input.substring(pos, index));\n    tokens.push({ type, content });\n    pos = index + content.length;\n  }\n  if (input.length > pos) tokens.push(input.substring(pos));\n  return tokens;\n}\n","import { ParticipantEvent, RoomEvent } from 'livekit-client';\n\nexport const allRemoteParticipantRoomEvents = [\n  RoomEvent.ConnectionStateChanged,\n  RoomEvent.RoomMetadataChanged,\n\n  RoomEvent.ActiveSpeakersChanged,\n  RoomEvent.ConnectionQualityChanged,\n\n  RoomEvent.ParticipantConnected,\n  RoomEvent.ParticipantDisconnected,\n  RoomEvent.ParticipantPermissionsChanged,\n  RoomEvent.ParticipantMetadataChanged,\n\n  RoomEvent.TrackMuted,\n  RoomEvent.TrackUnmuted,\n  RoomEvent.TrackPublished,\n  RoomEvent.TrackUnpublished,\n  RoomEvent.TrackStreamStateChanged,\n  RoomEvent.TrackSubscriptionFailed,\n  RoomEvent.TrackSubscriptionPermissionChanged,\n  RoomEvent.TrackSubscriptionStatusChanged,\n];\n\nexport const allParticipantRoomEvents = [\n  ...allRemoteParticipantRoomEvents,\n  RoomEvent.LocalTrackPublished,\n  RoomEvent.LocalTrackUnpublished,\n];\n\nexport const allRemoteParticipantEvents = [\n  ParticipantEvent.ConnectionQualityChanged,\n  ParticipantEvent.IsSpeakingChanged,\n  ParticipantEvent.ParticipantMetadataChanged,\n  ParticipantEvent.ParticipantPermissionsChanged,\n\n  ParticipantEvent.TrackMuted,\n  ParticipantEvent.TrackUnmuted,\n  ParticipantEvent.TrackPublished,\n  ParticipantEvent.TrackUnpublished,\n  ParticipantEvent.TrackStreamStateChanged,\n  ParticipantEvent.TrackSubscriptionFailed,\n  ParticipantEvent.TrackSubscriptionPermissionChanged,\n  ParticipantEvent.TrackSubscriptionStatusChanged,\n];\n\nexport const allParticipantEvents = [\n  ...allRemoteParticipantEvents,\n  ParticipantEvent.LocalTrackPublished,\n  ParticipantEvent.LocalTrackUnpublished,\n];\n","import {\n  setLogLevel as setClientSdkLogLevel,\n  setLogExtension as setClientSdkLogExtension,\n  LogLevel as LogLevelEnum,\n} from 'livekit-client';\nimport loglevel from 'loglevel';\n\nexport const log = loglevel.getLogger('lk-components-js');\nlog.setDefaultLevel('WARN');\n\ntype LogLevel = Parameters<typeof setClientSdkLogLevel>[0];\ntype SetLogLevelOptions = {\n  liveKitClientLogLevel?: LogLevel;\n};\n\n/**\n * Set the log level for both the `@livekit/components-react` package and the `@livekit-client` package.\n * To set the `@livekit-client` log independently, use the `liveKitClientLogLevel` prop on the `options` object.\n * @public\n */\nexport function setLogLevel(level: LogLevel, options: SetLogLevelOptions = {}): void {\n  log.setLevel(level);\n  setClientSdkLogLevel(options.liveKitClientLogLevel ?? level);\n}\n\ntype LogExtension = (level: LogLevel, msg: string, context?: object) => void;\ntype SetLogExtensionOptions = {\n  liveKitClientLogExtension?: LogExtension;\n};\n\n/**\n * Set the log extension for both the `@livekit/components-react` package and the `@livekit-client` package.\n * To set the `@livekit-client` log extension, use the `liveKitClientLogExtension` prop on the `options` object.\n * @public\n */\nexport function setLogExtension(extension: LogExtension, options: SetLogExtensionOptions = {}) {\n  const originalFactory = log.methodFactory;\n\n  log.methodFactory = (methodName, configLevel, loggerName) => {\n    const rawMethod = originalFactory(methodName, configLevel, loggerName);\n\n    const logLevel = LogLevelEnum[methodName];\n    const needLog = logLevel >= configLevel && logLevel < LogLevelEnum.silent;\n\n    return (msg, context?: [msg: string, context: object]) => {\n      if (context) rawMethod(msg, context);\n      else rawMethod(msg);\n      if (needLog) {\n        extension(logLevel, msg, context);\n      }\n    };\n  };\n  log.setLevel(log.getLevel()); // Be sure to call setLevel method in order to apply plugin\n  setClientSdkLogExtension(options.liveKitClientLogExtension ?? extension);\n}\n","import { log } from '../logger';\n\nexport type GridLayoutDefinition = {\n  /** Layout name (convention `<column_count>x<row_count>`). */\n  name: string;\n  /** Column count of the layout. */\n  columns: number;\n  /** Row count of the layout. */\n  rows: number;\n  // # Constraints that have to be meet to use this layout.\n  // ## 1. Participant range:\n  /** Minimum number of tiles needed to use this layout. */\n  minTiles: number;\n  /** Maximum tiles that fit into this layout. */\n  maxTiles: number;\n  // ## 2. Screen size limits:\n  /** Minimum width required to use this layout. */\n  minWidth: number;\n  /** Minimum height required to use this layout. */\n  minHeight: number;\n};\n\nexport const GRID_LAYOUTS: GridLayoutDefinition[] = [\n  {\n    columns: 1,\n    rows: 1,\n    name: '1x1',\n    minTiles: 1,\n    maxTiles: 1,\n    minWidth: 0,\n    minHeight: 0,\n  },\n  {\n    columns: 1,\n    rows: 2,\n    name: '1x2',\n    minTiles: 2,\n    maxTiles: 2,\n    minWidth: 0,\n    minHeight: 0,\n  },\n  {\n    columns: 2,\n    rows: 1,\n    name: '2x1',\n    minTiles: 2,\n    maxTiles: 2,\n    minWidth: 900,\n    minHeight: 0,\n  },\n  {\n    columns: 2,\n    rows: 2,\n    name: '2x2',\n    minTiles: 3,\n    maxTiles: 4,\n    minWidth: 560,\n    minHeight: 0,\n  },\n  {\n    columns: 3,\n    rows: 3,\n    name: '3x3',\n    minTiles: 5,\n    maxTiles: 9,\n    minWidth: 700,\n    minHeight: 0,\n  },\n  {\n    columns: 4,\n    rows: 4,\n    name: '4x4',\n    minTiles: 10,\n    maxTiles: 16,\n    minWidth: 960,\n    minHeight: 0,\n  },\n  {\n    columns: 5,\n    rows: 5,\n    name: '5x5',\n    minTiles: 17,\n    maxTiles: 25,\n    minWidth: 1100,\n    minHeight: 0,\n  },\n];\n\nexport function selectGridLayout(\n  layouts: GridLayoutDefinition[],\n  participantCount: number,\n  width: number,\n  height: number,\n): GridLayoutDefinition {\n  // Find the best layout to fit all participants.\n  let currentLayoutIndex = 0;\n  let layout = layouts.find((layout_, index, allLayouts) => {\n    currentLayoutIndex = index;\n    const isBiggerLayoutAvailable =\n      allLayouts.findIndex((l, i) => {\n        const layoutIsBiggerThanCurrent = i > index;\n        const layoutFitsSameAmountOfParticipants = l.maxTiles === layout_.maxTiles;\n        return layoutIsBiggerThanCurrent && layoutFitsSameAmountOfParticipants;\n      }) !== -1;\n    return layout_.maxTiles >= participantCount && !isBiggerLayoutAvailable;\n  });\n  if (layout === undefined) {\n    layout = layouts[layouts.length - 1];\n    if (layout) {\n      log.warn(\n        `No layout found for: participantCount: ${participantCount}, width/height: ${width}/${height} fallback to biggest available layout (${layout.name}).`,\n      );\n    } else {\n      throw new Error(`No layout or fallback layout found.`);\n    }\n  }\n\n  // Check if the layout fits into the screen constraints. If not, recursively check the next smaller layout.\n  if (width < layout.minWidth || height < layout.minHeight) {\n    // const currentLayoutIndex = layouts.indexOf(layout);\n    if (currentLayoutIndex > 0) {\n      const smallerLayout = layouts[currentLayoutIndex - 1];\n      layout = selectGridLayout(\n        layouts.slice(0, currentLayoutIndex),\n        smallerLayout.maxTiles,\n        width,\n        height,\n      );\n    }\n  }\n  return layout;\n}\n","export function setDifference<T>(setA: Set<T>, setB: Set<T>): Set<T> {\n  const _difference = new Set(setA);\n  for (const elem of setB) {\n    _difference.delete(elem);\n  }\n  return _difference;\n}\n","/**\n * Returns `true` if the browser supports screen sharing.\n */\nexport function supportsScreenSharing(): boolean {\n  return (\n    typeof navigator !== 'undefined' &&\n    navigator.mediaDevices &&\n    !!navigator.mediaDevices.getDisplayMedia\n  );\n}\n","import type { Participant, Track, TrackPublication } from 'livekit-client';\nimport type { TrackReference, TrackReferenceOrPlaceholder } from './track-reference';\n\n// ## PinState Type\n/** @public */\nexport type PinState = TrackReferenceOrPlaceholder[];\nexport const PIN_DEFAULT_STATE: PinState = [];\n\n// ## WidgetState Types\n/** @public */\nexport type WidgetState = {\n  showChat: boolean;\n  unreadMessages: number;\n};\nexport const WIDGET_DEFAULT_STATE: WidgetState = { showChat: false, unreadMessages: 0 };\n\n// ## Track Source Types\nexport type TrackSourceWithOptions = { source: Track.Source; withPlaceholder: boolean };\n\nexport type SourcesArray = Track.Source[] | TrackSourceWithOptions[];\n\n// ### Track Source Type Predicates\nexport function isSourceWitOptions(source: SourcesArray[number]): source is TrackSourceWithOptions {\n  return typeof source === 'object';\n}\n\nexport function isSourcesWithOptions(sources: SourcesArray): sources is TrackSourceWithOptions[] {\n  return (\n    Array.isArray(sources) &&\n    (sources as TrackSourceWithOptions[]).filter(isSourceWitOptions).length > 0\n  );\n}\n\n// ## Loop Filter Types\nexport type TrackReferenceFilter = Parameters<TrackReferenceOrPlaceholder[]['filter']>['0'];\nexport type ParticipantFilter = Parameters<Participant[]['filter']>['0'];\n\n// ## Other Types\n/** @internal */\nexport interface ParticipantClickEvent {\n  participant: Participant;\n  track?: TrackPublication;\n}\n\nexport type TrackSource<T extends Track.Source> = RequireAtLeastOne<\n  { source: T; name: string; participant: Participant },\n  'name' | 'source'\n>;\n\n/**\n * The TrackIdentifier type is used to select Tracks either based on\n * - Track.Source and/or name of the track, e.g. `{source: Track.Source.Camera}` or `{name: \"my-track\"}`\n * - TrackReference (participant and publication)\n */\nexport type TrackIdentifier<T extends Track.Source = Track.Source> =\n  | TrackSource<T>\n  | TrackReference;\n\n// ## Util Types\ntype RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<T, Exclude<keyof T, Keys>> &\n  {\n    [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>;\n  }[Keys];\n\nexport type RequireOnlyOne<T, Keys extends keyof T = keyof T> = Pick<T, Exclude<keyof T, Keys>> &\n  {\n    [K in Keys]-?: Required<Pick<T, K>> & Partial<Record<Exclude<Keys, K>, undefined>>;\n  }[Keys];\n\nexport type AudioSource = Track.Source.Microphone | Track.Source.ScreenShareAudio;\nexport type VideoSource = Track.Source.Camera | Track.Source.ScreenShare;\n","import { Track } from 'livekit-client';\nimport type { TrackReferenceOrPlaceholder } from '../track-reference';\nimport { isTrackReference } from '../track-reference';\nimport {\n  sortParticipantsByAudioLevel,\n  sortParticipantsByIsSpeaking,\n  sortParticipantsByJoinedAt,\n  sortParticipantsByLastSpokenAT,\n  sortTrackReferencesByType,\n  sortTrackRefsByIsCameraEnabled,\n} from './base-sort-functions';\n\n/**\n * Default sort for `TrackReferenceOrPlaceholder`, it'll order participants by:\n * 1. local camera track (publication.isLocal)\n * 2. remote screen_share track\n * 3. local screen_share track\n * 4. remote dominant speaker camera track (sorted by speaker with the loudest audio level)\n * 5. other remote speakers that are recently active\n * 6. remote unmuted camera tracks\n * 7. remote tracks sorted by joinedAt\n */\nexport function sortTrackReferences(\n  tracks: TrackReferenceOrPlaceholder[],\n): TrackReferenceOrPlaceholder[] {\n  const localTracks: TrackReferenceOrPlaceholder[] = [];\n  const screenShareTracks: TrackReferenceOrPlaceholder[] = [];\n  const cameraTracks: TrackReferenceOrPlaceholder[] = [];\n  const undefinedTracks: TrackReferenceOrPlaceholder[] = [];\n\n  tracks.forEach((trackRef) => {\n    if (trackRef.participant.isLocal && trackRef.source === Track.Source.Camera) {\n      localTracks.push(trackRef);\n    } else if (trackRef.source === Track.Source.ScreenShare) {\n      screenShareTracks.push(trackRef);\n    } else if (trackRef.source === Track.Source.Camera) {\n      cameraTracks.push(trackRef);\n    } else {\n      undefinedTracks.push(trackRef);\n    }\n  });\n\n  const sortedScreenShareTracks = sortScreenShareTracks(screenShareTracks);\n  const sortedCameraTracks = sortCameraTracks(cameraTracks);\n\n  return [...localTracks, ...sortedScreenShareTracks, ...sortedCameraTracks, ...undefinedTracks];\n}\n\n/**\n * Sort an array of `TrackReference` screen shares.\n * Main sorting order:\n * 1. remote screen shares\n * 2. local screen shares\n * Secondary sorting by participant's joining time.\n */\nfunction sortScreenShareTracks(\n  screenShareTracks: TrackReferenceOrPlaceholder[],\n): TrackReferenceOrPlaceholder[] {\n  const localScreenShares: TrackReferenceOrPlaceholder[] = [];\n  const remoteScreenShares: TrackReferenceOrPlaceholder[] = [];\n\n  screenShareTracks.forEach((trackRef) => {\n    if (trackRef.participant.isLocal) {\n      localScreenShares.push(trackRef);\n    } else {\n      remoteScreenShares.push(trackRef);\n    }\n  });\n\n  localScreenShares.sort((a, b) => sortParticipantsByJoinedAt(a.participant, b.participant));\n  remoteScreenShares.sort((a, b) => sortParticipantsByJoinedAt(a.participant, b.participant));\n\n  const sortedScreenShareTrackRefs = [...remoteScreenShares, ...localScreenShares];\n  return sortedScreenShareTrackRefs;\n}\n\nfunction sortCameraTracks(\n  cameraTrackReferences: TrackReferenceOrPlaceholder[],\n): TrackReferenceOrPlaceholder[] {\n  const localCameraTracks: TrackReferenceOrPlaceholder[] = [];\n  const remoteCameraTracks: TrackReferenceOrPlaceholder[] = [];\n\n  cameraTrackReferences.forEach((trackRef) => {\n    if (trackRef.participant.isLocal) {\n      localCameraTracks.push(trackRef);\n    } else {\n      remoteCameraTracks.push(trackRef);\n    }\n  });\n\n  remoteCameraTracks.sort((a, b) => {\n    // Participant with higher audio level goes first.\n    if (a.participant.isSpeaking && b.participant.isSpeaking) {\n      return sortParticipantsByAudioLevel(a.participant, b.participant);\n    }\n\n    // A speaking participant goes before one that is not speaking.\n    if (a.participant.isSpeaking !== b.participant.isSpeaking) {\n      return sortParticipantsByIsSpeaking(a.participant, b.participant);\n    }\n\n    // A participant that spoke recently goes before a participant that spoke a while back.\n    if (a.participant.lastSpokeAt !== b.participant.lastSpokeAt) {\n      return sortParticipantsByLastSpokenAT(a.participant, b.participant);\n    }\n\n    // TrackReference before TrackReferencePlaceholder\n    if (isTrackReference(a) !== isTrackReference(b)) {\n      return sortTrackReferencesByType(a, b);\n    }\n\n    // Tiles with video on before tiles with muted video track.\n    if (a.participant.isCameraEnabled !== b.participant.isCameraEnabled) {\n      return sortTrackRefsByIsCameraEnabled(a, b);\n    }\n\n    // A participant that joined a long time ago goes before one that joined recently.\n    return sortParticipantsByJoinedAt(a.participant, b.participant);\n  });\n\n  return [...localCameraTracks, ...remoteCameraTracks];\n}\n","import type { Participant } from 'livekit-client';\nimport { Track } from 'livekit-client';\nimport type { TrackReferenceOrPlaceholder } from '../track-reference';\nimport { getTrackReferenceSource, isTrackReference } from '../track-reference';\n\nexport function sortParticipantsByAudioLevel(\n  a: Pick<Participant, 'audioLevel'>,\n  b: Pick<Participant, 'audioLevel'>,\n): number {\n  return b.audioLevel - a.audioLevel;\n}\n\nexport function sortParticipantsByIsSpeaking(\n  a: Pick<Participant, 'isSpeaking'>,\n  b: Pick<Participant, 'isSpeaking'>,\n): number {\n  if (a.isSpeaking === b.isSpeaking) {\n    return 0;\n  } else {\n    return a.isSpeaking ? -1 : 1;\n  }\n}\n\nexport function sortParticipantsByLastSpokenAT(\n  a: Pick<Participant, 'lastSpokeAt'>,\n  b: Pick<Participant, 'lastSpokeAt'>,\n): number {\n  if (a.lastSpokeAt !== undefined || b.lastSpokeAt !== undefined) {\n    return (b.lastSpokeAt?.getTime() ?? 0) - (a.lastSpokeAt?.getTime() ?? 0);\n  } else {\n    return 0;\n  }\n}\n\nexport function sortParticipantsByJoinedAt(\n  a: Pick<Participant, 'joinedAt'>,\n  b: Pick<Participant, 'joinedAt'>,\n) {\n  return (a.joinedAt?.getTime() ?? 0) - (b.joinedAt?.getTime() ?? 0);\n}\n\nexport function sortTrackReferencesByType(\n  a: TrackReferenceOrPlaceholder,\n  b: TrackReferenceOrPlaceholder,\n) {\n  if (isTrackReference(a)) {\n    if (isTrackReference(b)) {\n      return 0;\n    } else {\n      return -1;\n    }\n  } else if (isTrackReference(b)) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\n/** TrackReference with screen share source goes first. */\nexport function sortTrackReferencesByScreenShare(\n  a: TrackReferenceOrPlaceholder,\n  b: TrackReferenceOrPlaceholder,\n): number {\n  const sourceA = getTrackReferenceSource(a);\n  const sourceB = getTrackReferenceSource(b);\n\n  if (sourceA === sourceB) {\n    if (sourceA === Track.Source.ScreenShare) {\n      if (a.participant.isLocal === b.participant.isLocal) {\n        return 0;\n      } else {\n        return a.participant.isLocal ? 1 : -1;\n      }\n    }\n    return 0;\n  } else if (sourceA === Track.Source.ScreenShare) {\n    return -1;\n  } else if (sourceB === Track.Source.ScreenShare) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nexport function sortTrackRefsByIsCameraEnabled(\n  a: { participant: { isCameraEnabled: boolean } },\n  b: { participant: { isCameraEnabled: boolean } },\n) {\n  const aVideo = a.participant.isCameraEnabled;\n  const bVideo = b.participant.isCameraEnabled;\n\n  if (aVideo !== bVideo) {\n    if (aVideo) {\n      return -1;\n    } else {\n      return 1;\n    }\n  } else {\n    return 0;\n  }\n}\n","import type { Participant } from 'livekit-client';\nimport { LocalParticipant } from 'livekit-client';\nimport {\n  sortParticipantsByAudioLevel,\n  sortParticipantsByIsSpeaking,\n  sortParticipantsByJoinedAt,\n  sortParticipantsByLastSpokenAT,\n} from './base-sort-functions';\n\n/**\n * Default sort for participants, it'll order participants by:\n * 1. local participant\n * 2. dominant speaker (speaker with the loudest audio level)\n * 3. other speakers that are recently active\n * 4. participants with video on\n * 5. by joinedAt\n */\nexport function sortParticipants(participants: Participant[]): Participant[] {\n  const sortedParticipants = [...participants];\n  sortedParticipants.sort((a, b) => {\n    // loudest speaker first\n    if (a.isSpeaking && b.isSpeaking) {\n      return sortParticipantsByAudioLevel(a, b);\n    }\n\n    // speaker goes first\n    if (a.isSpeaking !== b.isSpeaking) {\n      return sortParticipantsByIsSpeaking(a, b);\n    }\n\n    // last active speaker first\n    if (a.lastSpokeAt !== b.lastSpokeAt) {\n      return sortParticipantsByLastSpokenAT(a, b);\n    }\n\n    // video on\n    const aVideo = a.videoTracks.size > 0;\n    const bVideo = b.videoTracks.size > 0;\n    if (aVideo !== bVideo) {\n      if (aVideo) {\n        return -1;\n      } else {\n        return 1;\n      }\n    }\n\n    // joinedAt\n    return sortParticipantsByJoinedAt(a, b);\n  });\n  const localParticipant = sortedParticipants.find((p) => p instanceof LocalParticipant);\n  if (localParticipant) {\n    const localIdx = sortedParticipants.indexOf(localParticipant);\n    if (localIdx >= 0) {\n      sortedParticipants.splice(localIdx, 1);\n      if (sortedParticipants.length > 0) {\n        sortedParticipants.splice(0, 0, localParticipant);\n      } else {\n        sortedParticipants.push(localParticipant);\n      }\n    }\n  }\n  return sortedParticipants;\n}\n","export function chunk<T>(input: Array<T>, size: number) {\n  return input.reduce(\n    (arr, item, idx) => {\n      return idx % size === 0\n        ? [...arr, [item]]\n        : [...arr.slice(0, -1), [...arr.slice(-1)[0], item]];\n    },\n    [] as Array<Array<T>>,\n  );\n}\n\nexport function zip<T, U>(a1: Array<T>, a2: Array<U>) {\n  const resultLength = Math.max(a1.length, a2.length);\n  return new Array(resultLength).fill([]).map((_val, idx) => [a1[idx], a2[idx]]);\n}\n\nexport function differenceBy<T>(a1: Array<T>, a2: Array<T>, by: (arg: T) => string) {\n  return a1.filter((c) => !a2.map((v) => by(v)).includes(by(c)));\n}\n","/**\n * Internal test function.\n *\n * @internal\n */\n\nimport { Participant, Track, TrackPublication } from 'livekit-client';\nimport type { UpdatableItem } from '../sorting/tile-array-update';\nimport type { TrackReference, TrackReferencePlaceholder } from './track-reference.types';\nimport { getTrackReferenceId } from './track-reference.utils';\n\n// Test function:\nexport const mockTrackReferencePlaceholder = (\n  id: string,\n  source: Track.Source,\n): TrackReferencePlaceholder => {\n  return { participant: new Participant(`${id}`, `${id}`), source };\n};\n\nexport const mockTrackReferencePublished = (id: string, source: Track.Source): TrackReference => {\n  const kind = [Track.Source.Camera, Track.Source.ScreenShare].includes(source)\n    ? Track.Kind.Video\n    : Track.Kind.Audio;\n  return {\n    participant: new Participant(`${id}`, `${id}`),\n    publication: new TrackPublication(kind, `${id}`, `${id}`),\n    source: source,\n  };\n};\n\ntype mockTrackReferenceSubscribedOptions = {\n  mockPublication?: boolean;\n  mockParticipant?: boolean;\n  mockIsLocal?: boolean;\n};\n\nexport const mockTrackReferenceSubscribed = (\n  id: string,\n  source: Track.Source,\n  options: mockTrackReferenceSubscribedOptions = {},\n): TrackReference => {\n  const kind = [Track.Source.Camera, Track.Source.ScreenShare].includes(source)\n    ? Track.Kind.Video\n    : Track.Kind.Audio;\n\n  const publication = new TrackPublication(kind, `${id}`, `${id}`);\n  // @ts-expect-error\n  publication.track = {};\n  return {\n    participant: options.mockParticipant\n      ? (mockParticipant(id, options.mockIsLocal ?? false) as Participant)\n      : new Participant(`${id}`, `${id}`),\n    publication: options.mockPublication\n      ? (mockTrackPublication(`publicationId(${id})`, kind, source) as TrackPublication)\n      : publication,\n    source,\n  };\n};\n\nconst mockTrackPublication = (\n  id: string,\n  kind: Track.Kind,\n  source: Track.Source,\n): Pick<TrackPublication, 'kind' | 'trackSid' | 'trackName' | 'source'> => {\n  return {\n    kind,\n    trackSid: id,\n    trackName: `name_${id}`,\n    source: source,\n  };\n};\n\nfunction mockParticipant(\n  id: string,\n  isLocal: boolean,\n): Pick<Participant, 'sid' | 'identity' | 'isLocal'> {\n  return {\n    sid: `${id}_sid`,\n    identity: `${id}`,\n    isLocal: isLocal,\n  };\n}\n\nexport function flatTrackReferenceArray<T extends UpdatableItem>(list: T[]): string[] {\n  return list.map((item) => {\n    if (typeof item === 'string' || typeof item === 'number') {\n      return `${item}`;\n    } else {\n      return getTrackReferenceId(item);\n    }\n  });\n}\n","import { differenceBy, chunk, zip } from '../helper/array-helper';\nimport { log } from '../logger';\nimport type { TrackReferenceOrPlaceholder } from '../track-reference';\nimport {\n  getTrackReferenceId,\n  isPlaceholderReplacement,\n  isTrackReference,\n  isTrackReferencePlaceholder,\n} from '../track-reference';\nimport { flatTrackReferenceArray } from '../track-reference/test-utils';\n\ntype VisualChanges<T> = {\n  dropped: T[];\n  added: T[];\n};\n\nexport type UpdatableItem = TrackReferenceOrPlaceholder | number;\n\n/** Check to see if anything visually changes on the page. */\nexport function visualPageChange<T extends UpdatableItem>(state: T[], next: T[]): VisualChanges<T> {\n  return {\n    dropped: differenceBy(state, next, getTrackReferenceId),\n    added: differenceBy(next, state, getTrackReferenceId),\n  };\n}\n\nfunction listNeedsUpdating<T>(changes: VisualChanges<T>): boolean {\n  return changes.added.length !== 0 || changes.dropped.length !== 0;\n}\n\nexport function findIndex<T extends UpdatableItem>(\n  trackReference: T,\n  trackReferences: T[],\n): number {\n  const indexToReplace = trackReferences.findIndex(\n    (trackReference_) =>\n      getTrackReferenceId(trackReference_) === getTrackReferenceId(trackReference),\n  );\n  if (indexToReplace === -1) {\n    throw new Error(\n      `Element not part of the array: ${getTrackReferenceId(\n        trackReference,\n      )} not in ${flatTrackReferenceArray(trackReferences)}`,\n    );\n  }\n  return indexToReplace;\n}\n\n/** Swap items in the complete list of all elements */\nexport function swapItems<T extends UpdatableItem>(\n  moveForward: T,\n  moveBack: T,\n  trackReferences: T[],\n): T[] {\n  const indexToReplace = findIndex(moveForward, trackReferences);\n  const indexReplaceWith = findIndex(moveBack, trackReferences);\n\n  trackReferences.splice(indexToReplace, 1, moveBack);\n  trackReferences.splice(indexReplaceWith, 1, moveForward);\n\n  return trackReferences;\n}\n\nexport function dropItem<T extends UpdatableItem>(itemToDrop: T, list: T[]): T[] {\n  const indexOfElementToDrop = findIndex(itemToDrop, list);\n  // const indexOfElementToDrop = list.findIndex((item) => item === itemToDrop, list);\n  list.splice(indexOfElementToDrop, 1);\n  return list;\n}\n\nfunction addItem<T extends UpdatableItem>(itemToAdd: T, list: T[]): T[] {\n  return [...list, itemToAdd];\n}\n\nexport function divideIntoPages<T>(list: T[], maxElementsOnPage: number): Array<T[]> {\n  const pages = chunk(list, maxElementsOnPage);\n  return pages;\n}\n\n/** Divide the list of elements into pages and and check if pages need updating. */\nexport function updatePages<T extends UpdatableItem>(\n  currentList: T[],\n  nextList: T[],\n  maxItemsOnPage: number,\n): T[] {\n  let updatedList: T[] = refreshList(currentList, nextList);\n\n  if (updatedList.length < nextList.length) {\n    // Items got added: Find newly added items and add them to the end of the list.\n    const addedItems = differenceBy(nextList, updatedList, getTrackReferenceId);\n    updatedList = [...updatedList, ...addedItems];\n  }\n  const currentPages = divideIntoPages(updatedList, maxItemsOnPage);\n  const nextPages = divideIntoPages(nextList, maxItemsOnPage);\n\n  zip(currentPages, nextPages).forEach(([currentPage, nextPage], pageIndex) => {\n    if (currentPage && nextPage) {\n      // 1) Identify  missing tile.\n      const updatedPage = divideIntoPages(updatedList, maxItemsOnPage)[pageIndex];\n      const changes = visualPageChange(updatedPage, nextPage);\n\n      if (listNeedsUpdating(changes)) {\n        log.debug(\n          `Detected visual changes on page: ${pageIndex}, current: ${flatTrackReferenceArray(\n            currentPage,\n          )}, next: ${flatTrackReferenceArray(nextPage)}`,\n          { changes },\n        );\n        // ## Swap Items\n        if (changes.added.length === changes.dropped.length) {\n          zip(changes.added, changes.dropped).forEach(([added, dropped]) => {\n            if (added && dropped) {\n              updatedList = swapItems<T>(added, dropped, updatedList);\n            } else {\n              throw new Error(\n                `For a swap action we need a addition and a removal one is missing: ${added}, ${dropped}`,\n              );\n            }\n          });\n        }\n        // ## Handle Drop Items\n        if (changes.added.length === 0 && changes.dropped.length > 0) {\n          changes.dropped.forEach((item) => {\n            updatedList = dropItem<T>(item, updatedList);\n          });\n        }\n        // ## Handle Item added\n        if (changes.added.length > 0 && changes.dropped.length === 0) {\n          changes.added.forEach((item) => {\n            updatedList = addItem<T>(item, updatedList);\n          });\n        }\n      }\n    }\n  });\n\n  if (updatedList.length > nextList.length) {\n    // Items got removed: Find items that got completely removed from the list.\n    const missingItems = differenceBy(updatedList, nextList, getTrackReferenceId);\n    updatedList = updatedList.filter(\n      (item) => !missingItems.map(getTrackReferenceId).includes(getTrackReferenceId(item)),\n    );\n  }\n\n  return updatedList;\n}\n\n/**\n * Update the current list with the items from the next list whenever the item ids are the same\n * or the current item is a placeholder and we find a track reference in the next list\n * to replace the placeholder with.\n * @remarks\n * This is needed because `TrackReference`s can change their internal state while keeping the same id.\n */\nfunction refreshList<T extends UpdatableItem>(currentList: T[], nextList: T[]): T[] {\n  return currentList.map((currentItem) => {\n    const updateForCurrentItem = nextList.find(\n      (newItem_) =>\n        // If the IDs match or ..\n        getTrackReferenceId(currentItem) === getTrackReferenceId(newItem_) ||\n        // ... if the current item is a placeholder and the new item is the track reference can replace it.\n        (typeof currentItem !== 'number' &&\n          isTrackReferencePlaceholder(currentItem) &&\n          isTrackReference(newItem_) &&\n          isPlaceholderReplacement(currentItem, newItem_)),\n    );\n    return updateForCurrentItem ?? currentItem;\n  });\n}\n","import type {\n  AudioCaptureOptions,\n  LocalParticipant,\n  Room,\n  ScreenShareCaptureOptions,\n  VideoCaptureOptions,\n} from 'livekit-client';\nimport { Track } from 'livekit-client';\nimport type { Observable } from 'rxjs';\nimport { Subject, map, startWith } from 'rxjs';\nimport { observeParticipantMedia } from '../observables/participant';\nimport { prefixClass } from '../styles-interface';\n\nexport type CaptureOptionsBySource<T extends ToggleSource> = T extends Track.Source.Camera\n  ? VideoCaptureOptions\n  : T extends Track.Source.Microphone\n  ? AudioCaptureOptions\n  : T extends Track.Source.ScreenShare\n  ? ScreenShareCaptureOptions\n  : never;\n\nexport type MediaToggleType<T extends ToggleSource> = {\n  pendingObserver: Observable<boolean>;\n  toggle: (forceState?: boolean, captureOptions?: CaptureOptionsBySource<T>) => Promise<void>;\n  className: string;\n  enabledObserver: Observable<boolean>;\n};\n\nexport type ToggleSource = Exclude<\n  Track.Source,\n  Track.Source.ScreenShareAudio | Track.Source.Unknown\n>;\n\nexport function setupMediaToggle<T extends ToggleSource>(\n  source: T,\n  room: Room,\n  options?: CaptureOptionsBySource<T>,\n): MediaToggleType<T> {\n  const { localParticipant } = room;\n\n  const getSourceEnabled = (source: ToggleSource, localParticipant: LocalParticipant) => {\n    let isEnabled = false;\n    switch (source) {\n      case Track.Source.Camera:\n        isEnabled = localParticipant.isCameraEnabled;\n        break;\n      case Track.Source.Microphone:\n        isEnabled = localParticipant.isMicrophoneEnabled;\n        break;\n      case Track.Source.ScreenShare:\n        isEnabled = localParticipant.isScreenShareEnabled;\n        break;\n      default:\n        break;\n    }\n    return isEnabled;\n  };\n\n  const enabledObserver = observeParticipantMedia(localParticipant).pipe(\n    map((media) => {\n      return getSourceEnabled(source, media.participant as LocalParticipant);\n    }),\n    startWith(getSourceEnabled(source, localParticipant)),\n  );\n\n  const pendingSubject = new Subject<boolean>();\n  const toggle = async (forceState?: boolean, captureOptions?: CaptureOptionsBySource<T>) => {\n    try {\n      captureOptions ??= options;\n      // trigger observable update\n      pendingSubject.next(true);\n      switch (source) {\n        case Track.Source.Camera:\n          await localParticipant.setCameraEnabled(\n            forceState ?? !localParticipant.isCameraEnabled,\n            captureOptions as VideoCaptureOptions,\n          );\n          break;\n        case Track.Source.Microphone:\n          await localParticipant.setMicrophoneEnabled(\n            forceState ?? !localParticipant.isMicrophoneEnabled,\n            captureOptions as AudioCaptureOptions,\n          );\n          break;\n        case Track.Source.ScreenShare:\n          await localParticipant.setScreenShareEnabled(\n            forceState ?? !localParticipant.isScreenShareEnabled,\n            captureOptions as ScreenShareCaptureOptions,\n          );\n          break;\n        default:\n          break;\n      }\n    } finally {\n      pendingSubject.next(false);\n      // trigger observable update\n    }\n  };\n\n  const className: string = prefixClass('button');\n  return {\n    className,\n    toggle,\n    enabledObserver,\n    pendingObserver: pendingSubject.asObservable(),\n  };\n}\n\nexport function setupManualToggle() {\n  let state = false;\n\n  const enabledSubject = new Subject<boolean>();\n\n  const pendingSubject = new Subject<boolean>();\n\n  const toggle = async (forceState?: boolean) => {\n    pendingSubject.next(true);\n    state = forceState ?? !state;\n    enabledSubject.next(state);\n    pendingSubject.next(false);\n  };\n  const className: string = prefixClass('button');\n  return {\n    className,\n    toggle,\n    enabledObserver: enabledSubject.asObservable(),\n    pendingObserver: pendingSubject.asObservable(),\n  };\n}\n","import type { Participant, RemoteParticipant, Room, TrackPublication } from 'livekit-client';\nimport { ParticipantEvent, RoomEvent, Track } from 'livekit-client';\nimport type { Subscriber } from 'rxjs';\nimport { map, switchMap, Observable, startWith } from 'rxjs';\nimport { observeRoomEvents } from './room';\nimport type { ParticipantEventCallbacks } from 'livekit-client/dist/src/room/participant/Participant';\nimport { allParticipantEvents, allParticipantRoomEvents } from '../helper/eventGroups';\nimport type { TrackIdentifier } from '../types';\nimport { getTrackByIdentifier } from '../components/mediaTrack';\nimport { TrackReferenceOrPlaceholder } from '../track-reference';\n\nexport function observeParticipantEvents<T extends Participant>(\n  participant: T,\n  ...events: ParticipantEvent[]\n) {\n  const observable = new Observable<T>((subscribe) => {\n    const onParticipantUpdate = () => {\n      subscribe.next(participant);\n    };\n\n    events.forEach((evt) => {\n      participant.on(evt as keyof ParticipantEventCallbacks, onParticipantUpdate);\n    });\n\n    const unsubscribe = () => {\n      events.forEach((evt) => {\n        participant.off(evt as keyof ParticipantEventCallbacks, onParticipantUpdate);\n      });\n    };\n    return unsubscribe;\n  }).pipe(startWith(participant));\n\n  return observable;\n}\n\nexport interface ParticipantMedia<T extends Participant = Participant> {\n  isCameraEnabled: boolean;\n  isMicrophoneEnabled: boolean;\n  isScreenShareEnabled: boolean;\n  microphoneTrack?: TrackPublication;\n  cameraTrack?: TrackPublication;\n  participant: T;\n}\n\nexport function observeParticipantMedia<T extends Participant>(participant: T) {\n  const participantObserver = observeParticipantEvents(\n    participant,\n    ParticipantEvent.TrackMuted,\n    ParticipantEvent.TrackUnmuted,\n    ParticipantEvent.ParticipantPermissionsChanged,\n    // ParticipantEvent.IsSpeakingChanged,\n    ParticipantEvent.TrackPublished,\n    ParticipantEvent.TrackUnpublished,\n    ParticipantEvent.LocalTrackPublished,\n    ParticipantEvent.LocalTrackUnpublished,\n    ParticipantEvent.MediaDevicesError,\n    ParticipantEvent.TrackSubscriptionStatusChanged,\n    // ParticipantEvent.ConnectionQualityChanged,\n  ).pipe(\n    map((p) => {\n      const { isMicrophoneEnabled, isCameraEnabled, isScreenShareEnabled } = p;\n      const microphoneTrack = p.getTrack(Track.Source.Microphone);\n      const cameraTrack = p.getTrack(Track.Source.Camera);\n      const participantMedia: ParticipantMedia<T> = {\n        isCameraEnabled,\n        isMicrophoneEnabled,\n        isScreenShareEnabled,\n        cameraTrack,\n        microphoneTrack,\n        participant: p,\n      };\n      return participantMedia;\n    }),\n  );\n\n  return participantObserver;\n}\n\nexport function createTrackObserver(participant: Participant, options: TrackIdentifier) {\n  return observeParticipantMedia(participant).pipe(\n    map(() => {\n      return { publication: getTrackByIdentifier(options) };\n    }),\n  );\n}\n\nexport function participantInfoObserver(participant: Participant) {\n  const observer = observeParticipantEvents(\n    participant,\n    ParticipantEvent.ParticipantMetadataChanged,\n    // ParticipantEvent.LocalTrackPublished,\n  ).pipe(\n    map(({ name, identity, metadata }) => {\n      return {\n        name,\n        identity,\n        metadata,\n      };\n    }),\n    startWith({\n      name: participant.name,\n      identity: participant.identity,\n      metadata: participant.metadata,\n    }),\n  );\n  return observer;\n}\n\nexport function createConnectionQualityObserver(participant: Participant) {\n  const observer = participantEventSelector(\n    participant,\n    ParticipantEvent.ConnectionQualityChanged,\n  ).pipe(\n    map(([quality]) => quality),\n    startWith(participant.connectionQuality),\n  );\n  return observer;\n}\n\nexport function participantEventSelector<T extends ParticipantEvent>(\n  participant: Participant,\n  event: T,\n) {\n  const observable = new Observable<\n    Parameters<ParticipantEventCallbacks[Extract<T, keyof ParticipantEventCallbacks>]>\n  >((subscribe) => {\n    const update = (\n      ...params: Parameters<ParticipantEventCallbacks[Extract<T, keyof ParticipantEventCallbacks>]>\n    ) => {\n      subscribe.next(params);\n    };\n    // @ts-expect-error not a perfect overlap between ParticipantEvent and keyof ParticipantEventCallbacks\n    participant.on(event, update);\n\n    const unsubscribe = () => {\n      // @ts-expect-error not a perfect overlap between ParticipantEvent and keyof ParticipantEventCallbacks\n      participant.off(event, update);\n    };\n    return unsubscribe;\n  });\n\n  return observable;\n}\n\nexport function mutedObserver(trackRef: TrackReferenceOrPlaceholder) {\n  return observeParticipantEvents(\n    trackRef.participant,\n    ParticipantEvent.TrackMuted,\n    ParticipantEvent.TrackUnmuted,\n    ParticipantEvent.TrackSubscribed,\n    ParticipantEvent.TrackUnsubscribed,\n    ParticipantEvent.LocalTrackPublished,\n    ParticipantEvent.LocalTrackUnpublished,\n  ).pipe(\n    map((participant) => {\n      const pub = trackRef.publication ?? participant.getTrack(trackRef.source);\n      return pub?.isMuted ?? true;\n    }),\n    startWith(\n      trackRef.publication?.isMuted ??\n        trackRef.participant.getTrack(trackRef.source)?.isMuted ??\n        true,\n    ),\n  );\n}\n\nexport function createIsSpeakingObserver(participant: Participant) {\n  return participantEventSelector(participant, ParticipantEvent.IsSpeakingChanged).pipe(\n    map(([isSpeaking]) => isSpeaking),\n  );\n}\n\ntype ConnectedParticipantsObserverOptions = {\n  additionalRoomEvents?: RoomEvent[];\n};\n\nexport function connectedParticipantsObserver(\n  room: Room,\n  options: ConnectedParticipantsObserverOptions = {},\n) {\n  let subscriber: Subscriber<RemoteParticipant[]> | undefined;\n\n  const observable = new Observable<RemoteParticipant[]>((sub) => {\n    subscriber = sub;\n    return () => listener.unsubscribe();\n  }).pipe(startWith(Array.from(room.participants.values())));\n\n  const additionalRoomEvents = options.additionalRoomEvents ?? allParticipantRoomEvents;\n\n  const roomEvents = Array.from(\n    new Set([\n      RoomEvent.ParticipantConnected,\n      RoomEvent.ParticipantDisconnected,\n      RoomEvent.ConnectionStateChanged,\n      ...additionalRoomEvents,\n    ]),\n  );\n\n  const listener = observeRoomEvents(room, ...roomEvents).subscribe(\n    (r) => subscriber?.next(Array.from(r.participants.values())),\n  );\n  if (room.participants.size > 0) {\n    subscriber?.next(Array.from(room.participants.values()));\n  }\n  return observable;\n}\n\nexport type ConnectedParticipantObserverOptions = {\n  additionalEvents?: ParticipantEvent[];\n};\n\nexport function connectedParticipantObserver(\n  room: Room,\n  identity: string,\n  options: ConnectedParticipantObserverOptions = {},\n) {\n  const additionalEvents = options.additionalEvents ?? allParticipantEvents;\n  const observable = observeRoomEvents(\n    room,\n    RoomEvent.ParticipantConnected,\n    RoomEvent.ParticipantDisconnected,\n    RoomEvent.ConnectionStateChanged,\n  ).pipe(\n    switchMap((r) => {\n      const participant = r.getParticipantByIdentity(identity) as RemoteParticipant | undefined;\n      if (participant) {\n        return observeParticipantEvents(participant, ...additionalEvents);\n      } else {\n        return new Observable<undefined>((subscribe) => subscribe.next(undefined));\n      }\n    }),\n    startWith(room.getParticipantByIdentity(identity) as RemoteParticipant | undefined),\n  );\n\n  return observable;\n}\n\nexport function participantPermissionObserver(participant: Participant) {\n  const observer = participantEventSelector(\n    participant,\n    ParticipantEvent.ParticipantPermissionsChanged,\n  ).pipe(\n    map(() => participant.permissions),\n    startWith(participant.permissions),\n  );\n  return observer;\n}\n","import type { Subscriber, Subscription } from 'rxjs';\nimport { Subject, map, Observable, startWith, finalize, filter, concat } from 'rxjs';\nimport type { Participant, TrackPublication } from 'livekit-client';\nimport { LocalParticipant, Room, RoomEvent, Track } from 'livekit-client';\nimport type { RoomEventCallbacks } from 'livekit-client/dist/src/room/Room';\nimport { log } from '../logger';\nexport function observeRoomEvents(room: Room, ...events: RoomEvent[]): Observable<Room> {\n  const observable = new Observable<Room>((subscribe) => {\n    const onRoomUpdate = () => {\n      subscribe.next(room);\n    };\n\n    events.forEach((evt) => {\n      room.on(evt, onRoomUpdate);\n    });\n\n    const unsubscribe = () => {\n      events.forEach((evt) => {\n        room.off(evt, onRoomUpdate);\n      });\n    };\n    return unsubscribe;\n  }).pipe(startWith(room));\n\n  return observable;\n}\n\nexport function roomEventSelector<T extends RoomEvent>(room: Room, event: T) {\n  const observable = new Observable<Parameters<RoomEventCallbacks[T]>>((subscribe) => {\n    const update = (...params: Parameters<RoomEventCallbacks[T]>) => {\n      subscribe.next(params);\n    };\n    room.on(event as keyof RoomEventCallbacks, update);\n\n    const unsubscribe = () => {\n      room.off(event as keyof RoomEventCallbacks, update);\n    };\n    return unsubscribe;\n  });\n\n  return observable;\n}\n\nexport function roomObserver(room: Room) {\n  const observable = observeRoomEvents(\n    room,\n    RoomEvent.ParticipantConnected,\n    RoomEvent.ParticipantDisconnected,\n    RoomEvent.ActiveSpeakersChanged,\n    RoomEvent.TrackSubscribed,\n    RoomEvent.TrackUnsubscribed,\n    RoomEvent.LocalTrackPublished,\n    RoomEvent.LocalTrackUnpublished,\n    RoomEvent.AudioPlaybackStatusChanged,\n    RoomEvent.ConnectionStateChanged,\n  ).pipe(startWith(room));\n\n  return observable;\n}\n\nexport function connectionStateObserver(room: Room) {\n  return roomEventSelector(room, RoomEvent.ConnectionStateChanged).pipe(\n    map(([connectionState]) => connectionState),\n    startWith(room.state),\n  );\n}\nexport type ScreenShareTrackMap = Array<{\n  participant: Participant;\n  tracks: Array<TrackPublication>;\n}>;\n\nexport function screenShareObserver(room: Room) {\n  let screenShareSubscriber: Subscriber<ScreenShareTrackMap>;\n  const observers: Array<Subscription> = [];\n\n  const observable = new Observable<ScreenShareTrackMap>((subscriber) => {\n    screenShareSubscriber = subscriber;\n    return () => {\n      observers.forEach((observer) => {\n        observer.unsubscribe();\n      });\n    };\n  });\n  const screenShareTracks: ScreenShareTrackMap = [];\n\n  const handleSub = (publication: TrackPublication, participant: Participant) => {\n    if (\n      publication.source !== Track.Source.ScreenShare &&\n      publication.source !== Track.Source.ScreenShareAudio\n    ) {\n      return;\n    }\n    let trackMap = screenShareTracks.find((tr) => tr.participant.identity === participant.identity);\n    const getScreenShareTracks = (participant: Participant) => {\n      return participant\n        .getTracks()\n        .filter(\n          (track) =>\n            (track.source === Track.Source.ScreenShare ||\n              track.source === Track.Source.ScreenShareAudio) &&\n            track.track,\n        );\n    };\n    if (!trackMap) {\n      trackMap = {\n        participant,\n        tracks: getScreenShareTracks(participant),\n      };\n    } else {\n      const index = screenShareTracks.indexOf(trackMap);\n      screenShareTracks.splice(index, 1);\n      trackMap.tracks = getScreenShareTracks(participant);\n    }\n    if (trackMap.tracks.length > 0) {\n      screenShareTracks.push(trackMap);\n    }\n\n    screenShareSubscriber.next(screenShareTracks);\n  };\n  observers.push(\n    roomEventSelector(room, RoomEvent.TrackSubscribed).subscribe(([, ...args]) =>\n      handleSub(...args),\n    ),\n  );\n  observers.push(\n    roomEventSelector(room, RoomEvent.TrackUnsubscribed).subscribe(([, ...args]) =>\n      handleSub(...args),\n    ),\n  );\n  observers.push(\n    roomEventSelector(room, RoomEvent.LocalTrackPublished).subscribe((args) => handleSub(...args)),\n  );\n  observers.push(\n    roomEventSelector(room, RoomEvent.LocalTrackUnpublished).subscribe((args) => {\n      handleSub(...args);\n    }),\n  );\n  observers.push(\n    roomEventSelector(room, RoomEvent.TrackMuted).subscribe((args) => {\n      handleSub(...args);\n    }),\n  );\n  observers.push(\n    roomEventSelector(room, RoomEvent.TrackUnmuted).subscribe((args) => {\n      handleSub(...args);\n    }),\n  );\n  setTimeout(() => {\n    // TODO find way to avoid this timeout\n    for (const p of room.participants.values()) {\n      p.getTracks().forEach((track) => {\n        handleSub(track, p);\n      });\n    }\n  }, 1);\n\n  return observable;\n}\n\nexport function roomInfoObserver(room: Room) {\n  const observer = observeRoomEvents(\n    room,\n    RoomEvent.RoomMetadataChanged,\n    RoomEvent.ConnectionStateChanged,\n  ).pipe(\n    map((r) => {\n      return { name: r.name, metadata: r.metadata };\n    }),\n  );\n  return observer;\n}\n\nexport function activeSpeakerObserver(room: Room) {\n  return roomEventSelector(room, RoomEvent.ActiveSpeakersChanged).pipe(\n    map(([speakers]) => speakers),\n  );\n}\n\nexport function createMediaDeviceObserver(\n  kind?: MediaDeviceKind,\n  onError?: (e: Error) => void,\n  requestPermissions = true,\n) {\n  const onDeviceChange = async () => {\n    try {\n      const newDevices = await Room.getLocalDevices(kind, requestPermissions);\n      deviceSubject.next(newDevices);\n    } catch (e: any) {\n      onError?.(e);\n    }\n  };\n  const deviceSubject = new Subject<MediaDeviceInfo[]>();\n\n  const observable = deviceSubject.pipe(\n    finalize(() => {\n      navigator?.mediaDevices?.removeEventListener('devicechange', onDeviceChange);\n    }),\n  );\n\n  if (typeof window !== 'undefined') {\n    if (!window.isSecureContext) {\n      throw new Error(\n        `Accessing media devices is available only in secure contexts (HTTPS and localhost), in some or all supporting browsers. See: https://developer.mozilla.org/en-US/docs/Web/API/Navigator/mediaDevices`,\n      );\n    }\n    navigator?.mediaDevices?.addEventListener('devicechange', onDeviceChange);\n  }\n  // because we rely on an async function, concat the promise to retrieve the initial values with the observable\n  return concat(\n    Room.getLocalDevices(kind, requestPermissions).catch((e) => onError?.(e)),\n    observable,\n  );\n}\n\nexport function createDataObserver(room: Room) {\n  return roomEventSelector(room, RoomEvent.DataReceived);\n}\n\nexport function roomAudioPlaybackAllowedObservable(room: Room) {\n  const observable = observeRoomEvents(room, RoomEvent.AudioPlaybackStatusChanged).pipe(\n    map((room) => {\n      return { canPlayAudio: room.canPlaybackAudio };\n    }),\n  );\n  return observable;\n}\n\nexport function roomVideoPlaybackAllowedObservable(room: Room) {\n  const observable = observeRoomEvents(room, RoomEvent.VideoPlaybackStatusChanged).pipe(\n    map((room) => {\n      return { canPlayVideo: room.canPlaybackVideo };\n    }),\n  );\n  return observable;\n}\n\nexport function createActiveDeviceObservable(room: Room, kind: MediaDeviceKind) {\n  return roomEventSelector(room, RoomEvent.ActiveDeviceChanged).pipe(\n    filter(([kindOfDevice]) => kindOfDevice === kind),\n    map(([kind, deviceId]) => {\n      log.debug('activeDeviceObservable | RoomEvent.ActiveDeviceChanged', { kind, deviceId });\n      return deviceId;\n    }),\n    startWith(room.getActiveDevice(kind)),\n  );\n}\n\nexport function encryptionStatusObservable(room: Room, participant: Participant) {\n  return roomEventSelector(room, RoomEvent.ParticipantEncryptionStatusChanged).pipe(\n    filter(\n      ([, p]) =>\n        participant.identity === p?.identity ||\n        (!p && participant.identity === room.localParticipant.identity),\n    ),\n    map(([encrypted]) => encrypted),\n    startWith(\n      participant instanceof LocalParticipant ? participant.isE2EEEnabled : participant.isEncrypted,\n    ),\n  );\n}\n","import { Track } from 'livekit-client';\nimport { map, startWith } from 'rxjs';\nimport { observeParticipantMedia } from '../observables/participant';\nimport { prefixClass } from '../styles-interface';\nimport { isTrackReference } from '../track-reference/track-reference.types';\nimport type { TrackIdentifier } from '../types';\n\nexport function setupMediaTrack(trackIdentifier: TrackIdentifier) {\n  const initialPub = getTrackByIdentifier(trackIdentifier);\n  const trackObserver = observeParticipantMedia(trackIdentifier.participant).pipe(\n    map(() => {\n      return getTrackByIdentifier(trackIdentifier);\n    }),\n    startWith(initialPub),\n  );\n  const className: string = prefixClass(\n    trackIdentifier.source === Track.Source.Camera ||\n      trackIdentifier.source === Track.Source.ScreenShare\n      ? 'participant-media-video'\n      : 'participant-media-audio',\n  );\n  return { className, trackObserver };\n}\n\nexport function getTrackByIdentifier(options: TrackIdentifier) {\n  if (isTrackReference(options)) {\n    return options.publication;\n  } else {\n    const { source, name, participant } = options;\n    if (source && name) {\n      return participant.getTracks().find((pub) => pub.source === source && pub.trackName === name);\n    } else if (name) {\n      return participant.getTrackByName(name);\n    } else if (source) {\n      return participant.getTrack(source);\n    } else {\n      throw new Error('At least one of source and name needs to be defined');\n    }\n  }\n}\n","import type { UnprefixedClassNames as ComponentNoPrefixClasses } from '@livekit/components-styles/dist/types_unprefixed/index.scss';\nimport type { UnprefixedClassNames as PrefabNoPrefixClasses } from '@livekit/components-styles/dist/types_unprefixed/prefabs/index.scss';\nimport { cssPrefix } from './../constants';\n\ntype UnprefixedClassNames = ComponentNoPrefixClasses | PrefabNoPrefixClasses;\n\n/**\n * This function is a type safe way to add a prefix to a HTML class attribute.\n * Only classes defined in the styles module are valid, any other class produces a ts error.\n * @internal\n */\nexport function prefixClass<T extends UnprefixedClassNames>(unprefixedClassName: T) {\n  return `${cssPrefix}-${unprefixedClassName}` as const;\n}\n","import {\n  Track,\n  type LocalAudioTrack,\n  type LocalVideoTrack,\n  type Room,\n  type LocalTrack,\n} from 'livekit-client';\nimport { BehaviorSubject } from 'rxjs';\nimport { log } from '../logger';\nimport { prefixClass } from '../styles-interface';\nimport { createActiveDeviceObservable } from '../observables/room';\n\nexport type SetMediaDeviceOptions = {\n  /**\n   *  If true, adds an `exact` constraint to the getUserMedia request.\n   *  The request will fail if this option is true and the device specified is not actually available\n   */\n  exact?: boolean;\n};\n\nexport function setupDeviceSelector(\n  kind: MediaDeviceKind,\n  room?: Room,\n  localTrack?: LocalAudioTrack | LocalVideoTrack,\n) {\n  const activeDeviceSubject = new BehaviorSubject<string | undefined>(undefined);\n\n  const activeDeviceObservable = room\n    ? createActiveDeviceObservable(room, kind)\n    : activeDeviceSubject.asObservable();\n\n  const setActiveMediaDevice = async (id: string, options: SetMediaDeviceOptions = {}) => {\n    if (room) {\n      log.debug(`Switching active device of kind \"${kind}\" with id ${id}.`);\n      await room.switchActiveDevice(kind, id, options.exact);\n      const actualDeviceId: string | undefined = room.getActiveDevice(kind) ?? id;\n      if (actualDeviceId !== id && id !== 'default') {\n        log.info(\n          `We tried to select the device with id (${id}), but the browser decided to select the device with id (${actualDeviceId}) instead.`,\n        );\n      }\n      let targetTrack: LocalTrack | undefined = undefined;\n      if (kind === 'audioinput')\n        targetTrack = room.localParticipant.getTrack(Track.Source.Microphone)?.track;\n      else if (kind === 'videoinput') {\n        targetTrack = room.localParticipant.getTrack(Track.Source.Camera)?.track;\n      }\n      const useDefault =\n        (id === 'default' && !targetTrack) ||\n        (id === 'default' && targetTrack?.mediaStreamTrack.label.startsWith('Default'));\n      activeDeviceSubject.next(useDefault ? id : actualDeviceId);\n    } else if (localTrack) {\n      await localTrack.setDeviceId(options.exact ? { exact: id } : id);\n      const actualId = await localTrack.getDeviceId();\n      activeDeviceSubject.next(\n        id === 'default' && localTrack.mediaStreamTrack.label.startsWith('Default') ? id : actualId,\n      );\n    } else if (activeDeviceSubject.value !== id) {\n      log.warn(\n        'device switch skipped, please provide either a room or a local track to switch on. ',\n      );\n      activeDeviceSubject.next(id);\n    }\n  };\n  const className: string = prefixClass('media-device-select');\n  return {\n    className,\n    activeDeviceObservable,\n    setActiveMediaDevice,\n  };\n}\n","import type { Room } from 'livekit-client';\nimport { prefixClass } from '../styles-interface';\n\nexport function setupDisconnectButton(room: Room) {\n  const disconnect = (stopTracks?: boolean) => {\n    room.disconnect(stopTracks);\n  };\n  const className: string = prefixClass('disconnect-button');\n  return { className, disconnect };\n}\n","import type { Participant } from 'livekit-client';\nimport { createConnectionQualityObserver } from '../observables/participant';\nimport { prefixClass } from '../styles-interface';\n\nexport function setupConnectionQualityIndicator(participant: Participant) {\n  const className = prefixClass('connection-quality');\n  const connectionQualityObserver = createConnectionQualityObserver(participant);\n  return { className, connectionQualityObserver };\n}\n","import type { Styles } from '@livekit/components-styles/dist/types_unprefixed/index.scss';\nimport { Track } from 'livekit-client';\nimport { mutedObserver } from '../observables/participant';\nimport { prefixClass } from '../styles-interface';\nimport type { TrackReferenceOrPlaceholder } from '../track-reference';\n\nexport function setupTrackMutedIndicator(trackRef: TrackReferenceOrPlaceholder) {\n  let classForSource: keyof Styles = 'track-muted-indicator-camera';\n  switch (trackRef.source) {\n    case Track.Source.Camera:\n      classForSource = 'track-muted-indicator-camera';\n      break;\n    case Track.Source.Microphone:\n      classForSource = 'track-muted-indicator-microphone';\n      break;\n\n    default:\n      break;\n  }\n  const className: string = prefixClass(classForSource);\n  const mediaMutedObserver = mutedObserver(trackRef);\n\n  return { className, mediaMutedObserver };\n}\n","import type { Participant } from 'livekit-client';\nimport { participantInfoObserver } from '../observables/participant';\n\nexport function setupParticipantName(participant: Participant) {\n  const infoObserver = participantInfoObserver(participant);\n  return { className: 'lk-participant-name', infoObserver };\n}\n","import { prefixClass } from '../styles-interface';\n\nexport function setupParticipantTile() {\n  const className: string = prefixClass('participant-tile');\n  return {\n    className,\n  };\n}\n","/* eslint-disable camelcase */\nimport type { Participant, Room } from 'livekit-client';\nimport { DataPacket_Kind, RoomEvent } from 'livekit-client';\nimport { BehaviorSubject, Subject, scan, map, takeUntil } from 'rxjs';\nimport { DataTopic, sendMessage, setupDataMessageHandler } from '../observables/dataChannel';\n\n/** @public */\nexport interface ChatMessage {\n  timestamp: number;\n  message: string;\n}\n\n/** @public */\nexport interface ReceivedChatMessage extends ChatMessage {\n  from?: Participant;\n}\n\n/** @public */\nexport type MessageEncoder = (message: ChatMessage) => Uint8Array;\n/** @public */\nexport type MessageDecoder = (message: Uint8Array) => ReceivedChatMessage;\n/** @public */\nexport type ChatOptions = {\n  messageEncoder?: (message: ChatMessage) => Uint8Array;\n  messageDecoder?: (message: Uint8Array) => ReceivedChatMessage;\n  channelTopic?: string;\n};\n\ntype RawMessage = {\n  payload: Uint8Array;\n  topic: string | undefined;\n  from: Participant | undefined;\n};\n\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\n\nconst topicSubjectMap: Map<Room, Map<string, Subject<RawMessage>>> = new Map();\n\nconst encode = (message: ChatMessage) =>\n  encoder.encode(JSON.stringify({ message: message.message, timestamp: message.timestamp }));\n\nconst decode = (message: Uint8Array) => JSON.parse(decoder.decode(message)) as ReceivedChatMessage;\n\nexport function setupChat(room: Room, options?: ChatOptions) {\n  const onDestroyObservable = new Subject<void>();\n\n  const { messageDecoder, messageEncoder, channelTopic } = options ?? {};\n\n  const topic = channelTopic ?? DataTopic.CHAT;\n\n  let needsSetup = false;\n  if (!topicSubjectMap.has(room)) {\n    needsSetup = true;\n  }\n  const topicMap = topicSubjectMap.get(room) ?? new Map<string, Subject<RawMessage>>();\n  const messageSubject = topicMap.get(topic) ?? new Subject<RawMessage>();\n  topicMap.set(topic, messageSubject);\n  topicSubjectMap.set(room, topicMap);\n\n  if (needsSetup) {\n    /** Subscribe to all appropriate messages sent over the wire. */\n    const { messageObservable } = setupDataMessageHandler(room, topic);\n    messageObservable.pipe(takeUntil(onDestroyObservable)).subscribe(messageSubject);\n  }\n\n  const finalMessageDecoder = messageDecoder ?? decode;\n\n  /** Build up the message array over time. */\n  const messagesObservable = messageSubject.pipe(\n    map((msg) => {\n      const parsedMessage = finalMessageDecoder(msg.payload);\n      const newMessage: ReceivedChatMessage = { ...parsedMessage, from: msg.from };\n      return newMessage;\n    }),\n    scan<ReceivedChatMessage, ReceivedChatMessage[]>((acc, value) => [...acc, value], []),\n    takeUntil(onDestroyObservable),\n  );\n\n  const isSending$ = new BehaviorSubject<boolean>(false);\n\n  const finalMessageEncoder = messageEncoder ?? encode;\n\n  const send = async (message: string) => {\n    const timestamp = Date.now();\n    const encodedMsg = finalMessageEncoder({ message, timestamp });\n    isSending$.next(true);\n    try {\n      await sendMessage(room.localParticipant, encodedMsg, topic, {\n        kind: DataPacket_Kind.RELIABLE,\n      });\n      messageSubject.next({\n        payload: encodedMsg,\n        topic: topic,\n        from: room.localParticipant,\n      });\n    } finally {\n      isSending$.next(false);\n    }\n  };\n\n  function destroy() {\n    onDestroyObservable.next();\n    onDestroyObservable.complete();\n    topicSubjectMap.clear();\n  }\n  room.once(RoomEvent.Disconnected, destroy);\n\n  return { messageObservable: messagesObservable, isSendingObservable: isSending$, send };\n}\n","import type { LocalParticipant, Participant, Room } from 'livekit-client';\nimport { DataPacket_Kind } from 'livekit-client';\nimport type { Subscriber } from 'rxjs';\nimport { Observable, filter, map } from 'rxjs';\nimport { createDataObserver } from './room';\n\nexport const DataTopic = {\n  CHAT: 'lk-chat-topic',\n} as const;\n\nexport type DataSendOptions = {\n  kind?: DataPacket_Kind;\n  destination?: string[];\n};\n\n/** Publish data from the LocalParticipant. */\nexport async function sendMessage(\n  localParticipant: LocalParticipant,\n  payload: Uint8Array,\n  topic?: string,\n  options: DataSendOptions = {},\n) {\n  const { kind, destination } = options;\n\n  await localParticipant.publishData(payload, kind ?? DataPacket_Kind.RELIABLE, {\n    destination,\n    topic,\n  });\n}\n\nexport interface BaseDataMessage<T extends string | undefined> {\n  topic?: T;\n  payload: Uint8Array;\n}\n\nexport interface ReceivedDataMessage<T extends string | undefined = string>\n  extends BaseDataMessage<T> {\n  from?: Participant;\n}\n\nexport function setupDataMessageHandler<T extends string>(\n  room: Room,\n  topic?: T,\n  onMessage?: (msg: ReceivedDataMessage<T>) => void,\n) {\n  /** Setup a Observable that returns all data messages belonging to a topic. */\n  const messageObservable = createDataObserver(room).pipe(\n    filter(([, , , messageTopic]) => topic === undefined || messageTopic === topic),\n    map(([payload, participant, , messageTopic]) => {\n      const msg = {\n        payload,\n        topic: messageTopic as T,\n        from: participant,\n      } satisfies ReceivedDataMessage<T>;\n      onMessage?.(msg);\n      return msg;\n    }),\n  );\n\n  let isSendingSubscriber: Subscriber<boolean>;\n  const isSendingObservable = new Observable<boolean>((subscriber) => {\n    isSendingSubscriber = subscriber;\n  });\n\n  const send = async (payload: Uint8Array, options: DataSendOptions = {}) => {\n    isSendingSubscriber.next(true);\n    try {\n      await sendMessage(room.localParticipant, payload, topic, options);\n    } finally {\n      isSendingSubscriber.next(false);\n    }\n  };\n\n  return { messageObservable, isSendingObservable, send };\n}\n","import type { Room } from 'livekit-client';\nimport { log } from '../logger';\nimport { roomAudioPlaybackAllowedObservable } from '../observables/room';\nimport { prefixClass } from '../styles-interface';\n\nexport function setupStartAudio() {\n  const handleStartAudioPlayback = async (room: Room) => {\n    log.info('Start Audio for room: ', room);\n    await room.startAudio();\n  };\n  const className: string = prefixClass('start-audio-button');\n  return { className, roomAudioPlaybackAllowedObservable, handleStartAudioPlayback };\n}\n","import type { Room } from 'livekit-client';\nimport { log } from '../logger';\nimport { roomVideoPlaybackAllowedObservable } from '../observables/room';\nimport { prefixClass } from '../styles-interface';\n\nexport function setupStartVideo() {\n  const handleStartVideoPlayback = async (room: Room) => {\n    log.info('Start Video for room: ', room);\n    await room.startVideo();\n  };\n  const className: string = prefixClass('start-audio-button');\n  return { className, roomVideoPlaybackAllowedObservable, handleStartVideoPlayback };\n}\n","import { prefixClass } from '../styles-interface';\n\nexport function setupChatToggle() {\n  const className: string = [prefixClass('button'), prefixClass('chat-toggle')].join(' ');\n  return { className };\n}\n","import { prefixClass } from '../styles-interface';\n\nexport function setupFocusToggle() {\n  const className: string = [prefixClass('button'), prefixClass('focus-toggle-button')].join(' ');\n  return { className };\n}\n","// import { prefixClass } from '../styles-interface';\n\nexport function setupClearPinButton() {\n  // const className = prefixClass('clear-pin-button');\n  const className = 'lk-clear-pin-button lk-button';\n  return { className };\n}\n","export function setupLiveKitRoom() {\n  const className = 'lk-room-container';\n  return { className };\n}\n","import type {\n  LocalTrackPublication,\n  Participant,\n  RemoteTrackPublication,\n  Room,\n  Track,\n  TrackPublication,\n} from 'livekit-client';\nimport { RoomEvent, TrackEvent } from 'livekit-client';\nimport { map, Observable, startWith } from 'rxjs';\nimport { allParticipantRoomEvents } from '../helper';\nimport { log } from '../logger';\nimport type { TrackReference } from '../track-reference';\nimport { observeRoomEvents } from './room';\n\nexport function trackObservable(track: TrackPublication) {\n  const trackObserver = observeTrackEvents(\n    track,\n    TrackEvent.Muted,\n    TrackEvent.Unmuted,\n    TrackEvent.Subscribed,\n    TrackEvent.Unsubscribed,\n  );\n\n  return trackObserver;\n}\n\nexport function observeTrackEvents(track: TrackPublication, ...events: TrackEvent[]) {\n  const observable = new Observable<TrackPublication>((subscribe) => {\n    const onTrackUpdate = () => {\n      subscribe.next(track);\n    };\n\n    events.forEach((evt) => {\n      // @ts-expect-error type of `TrackEvent` and `PublicationCallbacks` are congruent\n      track.on(evt, onTrackUpdate);\n    });\n\n    const unsubscribe = () => {\n      events.forEach((evt) => {\n        // @ts-expect-error type of `TrackEvent` and `PublicationCallbacks` are congruent\n        track.off(evt, onTrackUpdate);\n      });\n    };\n    return unsubscribe;\n  }).pipe(startWith(track));\n\n  return observable;\n}\n\n/**\n * Create `TrackReferences` for all tracks that are included in the sources property.\n *  */\nfunction getTrackReferences(\n  room: Room,\n  sources: Track.Source[],\n  onlySubscribedTracks = true,\n): { trackReferences: TrackReference[]; participants: Participant[] } {\n  const localParticipant = room.localParticipant;\n  const allParticipants = [localParticipant, ...Array.from(room.participants.values())];\n  const trackReferences: TrackReference[] = [];\n\n  allParticipants.forEach((participant) => {\n    sources.forEach((source) => {\n      const sourceReferences = Array.from<RemoteTrackPublication | LocalTrackPublication>(\n        participant.tracks.values(),\n      )\n        .filter(\n          (track) =>\n            track.source === source &&\n            // either return all or only the ones that are subscribed\n            (!onlySubscribedTracks || track.track),\n        )\n        .map((track): TrackReference => {\n          return {\n            participant: participant,\n            publication: track,\n            source: track.source,\n          };\n        });\n\n      trackReferences.push(...sourceReferences);\n    });\n  });\n\n  return { trackReferences, participants: allParticipants };\n}\n\ntype TrackReferencesObservableOptions = {\n  additionalRoomEvents?: RoomEvent[];\n  onlySubscribed?: boolean;\n};\n\nexport function trackReferencesObservable(\n  room: Room,\n  sources: Track.Source[],\n  options: TrackReferencesObservableOptions,\n): Observable<{ trackReferences: TrackReference[]; participants: Participant[] }> {\n  const additionalRoomEvents = options.additionalRoomEvents ?? allParticipantRoomEvents;\n  const onlySubscribedTracks: boolean = options.onlySubscribed ?? true;\n  const roomEvents = Array.from(\n    new Set([\n      RoomEvent.ParticipantConnected,\n      RoomEvent.ParticipantDisconnected,\n      RoomEvent.ConnectionStateChanged,\n      RoomEvent.LocalTrackPublished,\n      RoomEvent.LocalTrackUnpublished,\n      RoomEvent.TrackPublished,\n      RoomEvent.TrackUnpublished,\n      RoomEvent.TrackSubscriptionStatusChanged,\n      ...additionalRoomEvents,\n    ]).values(),\n  );\n\n  const observable = observeRoomEvents(room, ...roomEvents).pipe(\n    map((room) => {\n      const data = getTrackReferences(room, sources, onlySubscribedTracks);\n      log.debug(`TrackReference[] was updated. (length ${data.trackReferences.length})`, data);\n      return data;\n    }),\n    startWith(getTrackReferences(room, sources, onlySubscribedTracks)),\n  );\n\n  return observable;\n}\n","import type { Observable } from 'rxjs';\nimport { concat, distinctUntilChanged, fromEvent, map, of, skipUntil, timeout } from 'rxjs';\n\n/**\n * Returns true if the user is interacting with the HTML element,\n * and returns false if there is no interaction for a specified period of time.\n *\n * @internal\n */\nexport function createInteractingObservable(htmlElement: HTMLElement | null, inactiveAfter = 1000) {\n  if (htmlElement === null) return of(false);\n  const move$ = fromEvent(htmlElement, 'mousemove', { passive: true }).pipe(map(() => true));\n  const moveAndStop$: Observable<boolean> = move$.pipe(\n    timeout({\n      each: inactiveAfter,\n      with: () => concat(of(false), moveAndStop$.pipe(skipUntil(move$))),\n    }),\n    distinctUntilChanged(),\n  );\n  return moveAndStop$;\n}\n","import { log } from '../logger';\n\ntype JsonPrimitive = string | number | boolean | null;\ntype JsonArray = JsonValue[];\ntype JsonObject = { [key: string]: JsonValue };\ntype JsonValue = JsonPrimitive | JsonArray | JsonObject;\n\n/**\n * Persists a serializable object to local storage associated with the specified key.\n * @internal\n */\nfunction saveToLocalStorage<T extends JsonValue>(key: string, value: T): void {\n  if (typeof localStorage === 'undefined') {\n    log.error('Local storage is not available.');\n    return;\n  }\n\n  try {\n    localStorage.setItem(key, JSON.stringify(value));\n  } catch (error) {\n    log.error(`Error setting item to local storage: ${error}`);\n  }\n}\n\n/**\n * Retrieves a serializable object from local storage by its key.\n * @internal\n */\nfunction loadFromLocalStorage<T extends JsonValue>(key: string): T | undefined {\n  if (typeof localStorage === 'undefined') {\n    log.error('Local storage is not available.');\n    return undefined;\n  }\n\n  try {\n    const item = localStorage.getItem(key);\n    if (!item) {\n      log.warn(`Item with key ${key} does not exist in local storage.`);\n      return undefined;\n    }\n    return JSON.parse(item);\n  } catch (error) {\n    log.error(`Error getting item from local storage: ${error}`);\n    return undefined;\n  }\n}\n\n/**\n * Generate a pair of functions to load and save a value of type T to local storage.\n * @internal\n */\nexport function createLocalStorageInterface<T extends JsonValue>(\n  key: string,\n): { load: () => T | undefined; save: (value: T) => void } {\n  return {\n    load: () => loadFromLocalStorage<T>(key),\n    save: (value: T) => saveToLocalStorage<T>(key, value),\n  };\n}\n","import { cssPrefix } from '../constants';\nimport { createLocalStorageInterface } from './local-storage-helpers';\n\nconst USER_CHOICES_KEY = `${cssPrefix}-user-choices` as const;\n\n/**\n * @public\n * Represents the user's choices for video and audio input devices,\n * as well as their username.\n */\nexport type LocalUserChoices = {\n  /**\n   * Whether video input is enabled.\n   * @defaultValue `true`\n   */\n  videoEnabled: boolean;\n  /**\n   * Whether audio input is enabled.\n   * @defaultValue `true`\n   */\n  audioEnabled: boolean;\n  /**\n   * The device ID of the video input device to use.\n   * @defaultValue `''`\n   */\n  videoDeviceId: string;\n  /**\n   * The device ID of the audio input device to use.\n   * @defaultValue `''`\n   */\n  audioDeviceId: string;\n  /**\n   * The username to use.\n   * @defaultValue `''`\n   */\n  username: string;\n  /** @deprecated This property will be removed without replacement. */\n  e2ee: boolean;\n  /** @deprecated This property will be removed without replacement. */\n  sharedPassphrase: string;\n};\n\nconst defaultUserChoices: LocalUserChoices = {\n  videoEnabled: true,\n  audioEnabled: true,\n  videoDeviceId: '',\n  audioDeviceId: '',\n  username: '',\n  e2ee: false,\n  sharedPassphrase: '',\n} as const;\n\n/**\n * The type of the object stored in local storage.\n * @remarks\n * TODO: Replace this type with `LocalUserChoices` after removing the deprecated properties from `LocalUserChoices`.\n * @internal\n */\ntype TempStorageType = Omit<LocalUserChoices, 'e2ee' | 'sharedPassphrase'>;\nconst { load, save } = createLocalStorageInterface<TempStorageType>(USER_CHOICES_KEY);\n\n/**\n * Saves user choices to local storage.\n * @alpha\n */\nexport function saveUserChoices(\n  userChoices: LocalUserChoices,\n  /**\n   * Whether to prevent saving user choices to local storage.\n   */\n  preventSave: boolean = false,\n): void {\n  if (preventSave === true) {\n    return;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const { e2ee, sharedPassphrase, ...toSave } = userChoices;\n  save(toSave);\n}\n\n/**\n * Reads the user choices from local storage, or returns the default settings if none are found.\n * @remarks\n * The deprecated parameters `e2ee` and `sharedPassphrase` are not read from local storage\n * and always return the value from the passed `defaults` or internal defaults.\n * @alpha\n */\nexport function loadUserChoices(\n  defaults?: Partial<LocalUserChoices>,\n  /**\n   * Whether to prevent loading from local storage and return default values instead.\n   * @defaultValue false\n   */\n  preventLoad: boolean = false,\n): LocalUserChoices {\n  const fallback: LocalUserChoices = {\n    videoEnabled: defaults?.videoEnabled ?? defaultUserChoices.videoEnabled,\n    audioEnabled: defaults?.audioEnabled ?? defaultUserChoices.audioEnabled,\n    videoDeviceId: defaults?.videoDeviceId ?? defaultUserChoices.videoDeviceId,\n    audioDeviceId: defaults?.audioDeviceId ?? defaultUserChoices.audioDeviceId,\n    username: defaults?.username ?? defaultUserChoices.username,\n    e2ee: defaults?.e2ee ?? defaultUserChoices.e2ee,\n    sharedPassphrase: defaults?.sharedPassphrase ?? defaultUserChoices.sharedPassphrase,\n  };\n\n  if (preventLoad) {\n    return fallback;\n  } else {\n    const maybeLoadedObject = load();\n    const result = { ...fallback, ...(maybeLoadedObject ?? {}) };\n    return result;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}